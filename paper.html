<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.340">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Herbert Susmann">
<meta name="author" content="Antoine Chambaz">
<meta name="author" content="Julie Josse">
<meta name="dcterms.date" content="2023-10-09">
<meta name="keywords" content="Conformal inference, Adaptive conformal inference, time series, R">
<meta name="description" content="Conformal Inference (CI) is a popular approach for generating finite sample prediction intervals based on the output of any point prediction method when data are exchangeable. Adaptive Conformal Inference (ACI) algorithms extend CI to the case of sequentially observed data, such as time series, and exhibit strong theoretical guarantees without having to assume exchangeability of the observed data. The common thread that unites algorithms in the ACI family is that they adaptively adjust the width of the generated prediction intervals in response to the observed data. We provide a detailed description of five ACI algorithms and their theoretical guarantees, and test their performance in simulation studies. We then present a case study of producing prediction intervals for influenza incidence in the United States based on black-box point forecasts. Implementations of all the algorithms are released as an open-source R package, AdaptiveConformal, which also includes tools for visualizing and summarizing conformal prediction intervals.">

<title>AdaptiveConformal: An R Package for Adaptive Conformal Inference</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="paper_files/libs/clipboard/clipboard.min.js"></script>
<script src="paper_files/libs/quarto-html/quarto.js"></script>
<script src="paper_files/libs/quarto-html/popper.min.js"></script>
<script src="paper_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="paper_files/libs/quarto-html/anchor.min.js"></script>
<link href="paper_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="paper_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="paper_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="paper_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="paper_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script src="paper_files/libs/quarto-contrib/pseudocode-2.4/pseudocode.min.js"></script>
<link href="paper_files/libs/quarto-contrib/pseudocode-2.4/pseudocode.min.css" rel="stylesheet">
<style>

      .quarto-title-block .quarto-title-banner h1,
      .quarto-title-block .quarto-title-banner h2,
      .quarto-title-block .quarto-title-banner h3,
      .quarto-title-block .quarto-title-banner h4,
      .quarto-title-block .quarto-title-banner h5,
      .quarto-title-block .quarto-title-banner h6
      {
        color: #FFFFFF;
      }

      .quarto-title-block .quarto-title-banner {
        color: #FFFFFF;
background: #034E79;
      }
</style>

  <script>window.backupDefine = window.define; window.define = undefined;</script><script src="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js"></script>
  <script>document.addEventListener("DOMContentLoaded", function () {
 var mathElements = document.getElementsByClassName("math");
 var macros = [];
 for (var i = 0; i < mathElements.length; i++) {
  var texText = mathElements[i].firstChild;
  if (mathElements[i].tagName == "SPAN") {
   katex.render(texText.data, mathElements[i], {
    displayMode: mathElements[i].classList.contains('display'),
    throwOnError: false,
    macros: macros,
    fleqn: false
   });
}}});
  </script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css">

</head>

<body>

<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <div class="quarto-title-block"><div><h1 class="title"><a href="https://computo.sfds.asso.fr">
        <img src="https://computo.sfds.asso.fr/assets/img/logo_notext_white.png" height="60px">
      </a> &nbsp; AdaptiveConformal: An <code>R</code> Package for Adaptive Conformal Inference</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> source</button></div></div>
            <p class="subtitle lead">AdaptiveConformal: An <code>R</code> Package for Adaptive Conformal Inference</p>
            <p><a href="http://creativecommons.org/licenses/by/4.0/"><img src="https://i.creativecommons.org/l/by/4.0/80x15.png" alt="Creative Commons BY License"></a>
ISSN 2824-7795</p>
            <div>
        <div class="description">
          <p>Conformal Inference (CI) is a popular approach for generating finite sample prediction intervals based on the output of any point prediction method when data are exchangeable. Adaptive Conformal Inference (ACI) algorithms extend CI to the case of sequentially observed data, such as time series, and exhibit strong theoretical guarantees without having to assume exchangeability of the observed data. The common thread that unites algorithms in the ACI family is that they adaptively adjust the width of the generated prediction intervals in response to the observed data. We provide a detailed description of five ACI algorithms and their theoretical guarantees, and test their performance in simulation studies. We then present a case study of producing prediction intervals for influenza incidence in the United States based on black-box point forecasts. Implementations of all the algorithms are released as an open-source <code>R</code> package, <code>AdaptiveConformal</code>, which also includes tools for visualizing and summarizing conformal prediction intervals.</p>
        </div>
      </div>
                </div>
  </div>
    
    <div class="quarto-title-meta-author">
      <div class="quarto-title-meta-heading">Authors</div>
      <div class="quarto-title-meta-heading">Affiliations</div>
          
          <div class="quarto-title-meta-contents">
        <a href="https://herbsusmann.com">Herbert Susmann</a> <a href="https://orcid.org/0000-0002-3540-8255" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://www.ceremade.dauphine.fr/">
                  CEREMADE (UMR 7534), Université Paris Dauphine - PSL, Place du Maréchal de Lattre de Tassigny, Paris, 75016, France
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="https://helios2.mi.parisdescartes.fr/~chambaz/">Antoine Chambaz</a> <a href="https://orcid.org/0000-0002-5592-6471" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://map5.mi.parisdescartes.fr/">
                  MAP5 (UMR 8145), Université Paris Cité
                  </a>
                </p>
            </div>
            <div class="quarto-title-meta-contents">
        <a href="http://juliejosse.com/">Julie Josse</a> <a href="https://orcid.org/0000-0001-9547-891X" class="quarto-title-author-orcid"> <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA2ZpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOk9yaWdpbmFsRG9jdW1lbnRJRD0ieG1wLmRpZDo1N0NEMjA4MDI1MjA2ODExOTk0QzkzNTEzRjZEQTg1NyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDozM0NDOEJGNEZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDozM0NDOEJGM0ZGNTcxMUUxODdBOEVCODg2RjdCQ0QwOSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgQ1M1IE1hY2ludG9zaCI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOkZDN0YxMTc0MDcyMDY4MTE5NUZFRDc5MUM2MUUwNEREIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjU3Q0QyMDgwMjUyMDY4MTE5OTRDOTM1MTNGNkRBODU3Ii8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+84NovQAAAR1JREFUeNpiZEADy85ZJgCpeCB2QJM6AMQLo4yOL0AWZETSqACk1gOxAQN+cAGIA4EGPQBxmJA0nwdpjjQ8xqArmczw5tMHXAaALDgP1QMxAGqzAAPxQACqh4ER6uf5MBlkm0X4EGayMfMw/Pr7Bd2gRBZogMFBrv01hisv5jLsv9nLAPIOMnjy8RDDyYctyAbFM2EJbRQw+aAWw/LzVgx7b+cwCHKqMhjJFCBLOzAR6+lXX84xnHjYyqAo5IUizkRCwIENQQckGSDGY4TVgAPEaraQr2a4/24bSuoExcJCfAEJihXkWDj3ZAKy9EJGaEo8T0QSxkjSwORsCAuDQCD+QILmD1A9kECEZgxDaEZhICIzGcIyEyOl2RkgwAAhkmC+eAm0TAAAAABJRU5ErkJggg=="></a>
      </div>
          
          <div class="quarto-title-meta-contents">
              <p class="affiliation">
                  <a href="https://team.inria.fr/premedical/">
                  Inria PreMeDICaL team, Université de Montpellier
                  </a>
                </p>
            </div>
        </div>
                    
  <div class="quarto-title-meta">
                                
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 9, 2023</p>
      </div>
    </div>
                                    
      <div>
      <div class="quarto-title-meta-heading">Modified</div>
      <div class="quarto-title-meta-contents">
        <p class="date-modified">October 9, 2023</p>
      </div>
    </div>
      
                  
      <div>
      <div class="quarto-title-meta-heading">Keywords</div>
      <div class="quarto-title-meta-contents">
        <p class="date">Conformal inference, Adaptive conformal inference, time series, R</p>
      </div>
    </div>
    
    <div>
      <div class="quarto-title-meta-heading">Status</div>
      <div class="quarto-title-meta-contents">
              <p class="date">draft</p>
                  </div>
    </div>

  </div>
                                                
  <div>
    <div class="abstract">
    <div class="abstract-title">Abstract</div>
      <p>Conformal Inference (CI) is a popular approach for generating finite sample prediction intervals based on the output of any point prediction method when data are exchangeable. Adaptive Conformal Inference (ACI) algorithms extend CI to the case of sequentially observed data, such as time series, and exhibit strong theoretical guarantees without having to assume exchangeability of the observed data. The common thread that unites algorithms in the ACI family is that they adaptively adjust the width of the generated prediction intervals in response to the observed data. We provide a detailed description of five ACI algorithms and their theoretical guarantees, and test their performance in simulation studies. We then present a case study of producing prediction intervals for influenza incidence in the United States based on black-box point forecasts. Implementations of all the algorithms are released as an open-source <code>R</code> package, <code>AdaptiveConformal</code>, which also includes tools for visualizing and summarizing conformal prediction intervals.</p>
    </div>
  </div>

  </header><div id="quarto-content" class="page-columns page-rows-contents page-layout-article">
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
  <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">1</span> Introduction</a></li>
  <li><a href="#sec-theory" id="toc-sec-theory" class="nav-link" data-scroll-target="#sec-theory"><span class="header-section-number">2</span> Theoretical Framework</a>
  <ul class="collapse">
  <li><a href="#linear-intervals" id="toc-linear-intervals" class="nav-link" data-scroll-target="#linear-intervals"><span class="header-section-number">2.1</span> Linear Intervals</a></li>
  <li><a href="#quantile-intervals" id="toc-quantile-intervals" class="nav-link" data-scroll-target="#quantile-intervals"><span class="header-section-number">2.2</span> Quantile Intervals</a></li>
  <li><a href="#online-learning-framework" id="toc-online-learning-framework" class="nav-link" data-scroll-target="#online-learning-framework"><span class="header-section-number">2.3</span> Online Learning Framework</a></li>
  <li><a href="#assessing-aci-algorithms" id="toc-assessing-aci-algorithms" class="nav-link" data-scroll-target="#assessing-aci-algorithms"><span class="header-section-number">2.4</span> Assessing ACI algorithms</a></li>
  </ul></li>
  <li><a href="#sec-algorithms" id="toc-sec-algorithms" class="nav-link" data-scroll-target="#sec-algorithms"><span class="header-section-number">3</span> Algorithms</a>
  <ul class="collapse">
  <li><a href="#adaptive-conformal-inference-aci" id="toc-adaptive-conformal-inference-aci" class="nav-link" data-scroll-target="#adaptive-conformal-inference-aci"><span class="header-section-number">3.1</span> Adaptive Conformal Inference (ACI)</a>
  <ul class="collapse">
  <li><a href="#theoretical-guarantees" id="toc-theoretical-guarantees" class="nav-link" data-scroll-target="#theoretical-guarantees"><span class="header-section-number">3.1.1</span> Theoretical Guarantees</a></li>
  <li><a href="#tuning-parameters" id="toc-tuning-parameters" class="nav-link" data-scroll-target="#tuning-parameters"><span class="header-section-number">3.1.2</span> Tuning Parameters</a></li>
  </ul></li>
  <li><a href="#aggregated-adaptive-conformal-inference-agaci" id="toc-aggregated-adaptive-conformal-inference-agaci" class="nav-link" data-scroll-target="#aggregated-adaptive-conformal-inference-agaci"><span class="header-section-number">3.2</span> Aggregated Adaptive Conformal Inference (AgACI)</a>
  <ul class="collapse">
  <li><a href="#theoretical-gaurantees" id="toc-theoretical-gaurantees" class="nav-link" data-scroll-target="#theoretical-gaurantees"><span class="header-section-number">3.2.1</span> Theoretical Gaurantees</a></li>
  <li><a href="#tuning-parameters-1" id="toc-tuning-parameters-1" class="nav-link" data-scroll-target="#tuning-parameters-1"><span class="header-section-number">3.2.2</span> Tuning Parameters</a></li>
  </ul></li>
  <li><a href="#fully-adaptive-conformal-inference-faci" id="toc-fully-adaptive-conformal-inference-faci" class="nav-link" data-scroll-target="#fully-adaptive-conformal-inference-faci"><span class="header-section-number">3.3</span> Fully Adaptive Conformal Inference (FACI)</a>
  <ul class="collapse">
  <li><a href="#theoretical-guarantees-1" id="toc-theoretical-guarantees-1" class="nav-link" data-scroll-target="#theoretical-guarantees-1"><span class="header-section-number">3.3.1</span> Theoretical Guarantees</a></li>
  <li><a href="#tuning-parameters-2" id="toc-tuning-parameters-2" class="nav-link" data-scroll-target="#tuning-parameters-2"><span class="header-section-number">3.3.2</span> Tuning parameters</a></li>
  </ul></li>
  <li><a href="#scale-free-online-gradient-descent-sf-ogd" id="toc-scale-free-online-gradient-descent-sf-ogd" class="nav-link" data-scroll-target="#scale-free-online-gradient-descent-sf-ogd"><span class="header-section-number">3.4</span> Scale-Free Online Gradient Descent (SF-OGD)</a>
  <ul class="collapse">
  <li><a href="#theoretical-guarantees-2" id="toc-theoretical-guarantees-2" class="nav-link" data-scroll-target="#theoretical-guarantees-2"><span class="header-section-number">3.4.1</span> Theoretical Guarantees</a></li>
  <li><a href="#tuning-parameters-3" id="toc-tuning-parameters-3" class="nav-link" data-scroll-target="#tuning-parameters-3"><span class="header-section-number">3.4.2</span> Tuning parameters</a></li>
  </ul></li>
  <li><a href="#strongly-adaptive-online-conformal-prediction-saocp" id="toc-strongly-adaptive-online-conformal-prediction-saocp" class="nav-link" data-scroll-target="#strongly-adaptive-online-conformal-prediction-saocp"><span class="header-section-number">3.5</span> Strongly Adaptive Online Conformal Prediction (SAOCP)</a>
  <ul class="collapse">
  <li><a href="#theoretical-guarantees-3" id="toc-theoretical-guarantees-3" class="nav-link" data-scroll-target="#theoretical-guarantees-3"><span class="header-section-number">3.5.1</span> Theoretical Guarantees</a></li>
  <li><a href="#tuning-parameters-4" id="toc-tuning-parameters-4" class="nav-link" data-scroll-target="#tuning-parameters-4"><span class="header-section-number">3.5.2</span> Tuning Parameters</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#sec-simulations" id="toc-sec-simulations" class="nav-link" data-scroll-target="#sec-simulations"><span class="header-section-number">4</span> Simulation Studies</a>
  <ul class="collapse">
  <li><a href="#time-series-with-arma-errors" id="toc-time-series-with-arma-errors" class="nav-link" data-scroll-target="#time-series-with-arma-errors"><span class="header-section-number">4.1</span> Time series with ARMA errors</a></li>
  <li><a href="#distribution-shift" id="toc-distribution-shift" class="nav-link" data-scroll-target="#distribution-shift"><span class="header-section-number">4.2</span> Distribution shift</a></li>
  </ul></li>
  <li><a href="#sec-case-study" id="toc-sec-case-study" class="nav-link" data-scroll-target="#sec-case-study"><span class="header-section-number">5</span> Case Study: Influenza Forecasting</a></li>
  <li><a href="#sec-discussion" id="toc-sec-discussion" class="nav-link" data-scroll-target="#sec-discussion"><span class="header-section-number">6</span> Discussion</a>
  <ul class="collapse">
  <li><a href="#acknowledgements" id="toc-acknowledgements" class="nav-link" data-scroll-target="#acknowledgements">Acknowledgements</a></li>
  </ul></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  <li><a href="#appendix" id="toc-appendix" class="nav-link" data-scroll-target="#appendix"><span class="header-section-number">7</span> Appendix</a>
  <ul class="collapse">
  <li><a href="#additional-simulation-study-results" id="toc-additional-simulation-study-results" class="nav-link" data-scroll-target="#additional-simulation-study-results"><span class="header-section-number">7.1</span> Additional simulation study results</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="paper.pdf"><i class="bi bi-file-pdf"></i>PDF (computo)</a></li></ul></div></nav>
</div>
<main class="content quarto-banner-title-block" id="quarto-document-content">



<section id="introduction" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Introduction</h1>
<p>Conformal Inference (CI) is a family of methods for generating finite sample prediction intervals around point predictions when data are exchangeable <span class="citation" data-cites="vovk2005 shafer2008conformal angelopoulos2022gentle">(<a href="#ref-vovk2005" role="doc-biblioref">Vovk, Gammerman, and Shafer 2005</a>; <a href="#ref-shafer2008conformal" role="doc-biblioref">Shafer and Vovk 2008</a>; <a href="#ref-angelopoulos2022gentle" role="doc-biblioref">Angelopoulos and Bates 2022</a>)</span>. The input point predictions can be derived from any prediction method, making CI a powerful tool for augmenting black-box prediction algorithms with prediction intervals. Classical CI methods are able to yield marginally valid intervals with only the assumption that the joint distribution of the data does not change based on the order of the observations (that is, they are exchangeable). However, in many real-world settings data are not exchangeable: for example, time series data usually cannot be assumed to be exchangeable due to temporal dependence. A recent line of research examines the problem of generating prediction intervals for observations that are observed online (that is, one at a time) and for which exchangeability is not assumed to hold <span class="citation" data-cites="gibbs2021adaptive zaffran2022agaci gibbs2022faci bhatnagar2023saocp">(<a href="#ref-gibbs2021adaptive" role="doc-biblioref">Gibbs and Candès 2021</a>, <a href="#ref-gibbs2022faci" role="doc-biblioref">2022</a>; <a href="#ref-zaffran2022agaci" role="doc-biblioref">Zaffran et al. 2022</a>; <a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span>. The methods from this literature, which we refer to generally as <em>Adaptive Conformal Inference</em> (ACI) algorithms, work by adaptively adjusting the width of the generated prediction intervals in response to the observed data.</p>
<p>Informally, suppose a sequence of outcomes <span class="math inline">y_t \in \mathbb{R}</span>, <span class="math inline">t = 1, \dots, T</span> are observed one at a time. Before seeing each observation, we have at our disposal a point prediction <span class="math inline">\hat{\mu}_t \in \mathbb{R}</span> that can be generated by any method. Our goal is to find an algorithm for producing prediction intervals <span class="math inline">[\ell_t, u_t]</span>, <span class="math inline">\ell_t \leq u_t</span> such that, in the long run, the observations <span class="math inline">y_t</span> fall within the corresponding prediction intervals roughly <span class="math inline">\alpha \times 100\%</span> of the time: that is, <span class="math inline">\lim_{T \to \infty} \sfrac{1}{T} \sum_{t=1}^T \mathbb{I}\{ y_t \in [\ell_t, u_t] \} = \alpha</span>. The original ACI algorithm <span class="citation" data-cites="gibbs2021adaptive">(<a href="#ref-gibbs2021adaptive" role="doc-biblioref">Gibbs and Candès 2021</a>)</span> is based on a simple idea: if the previous prediction interval at time <span class="math inline">(t-1)</span> did not cover the true observation, then the next prediction interval at time <span class="math inline">t</span> is made slightly wider. Conversely, if the previous prediction interval did include the observation, then the next prediction interval is made slightly narrower. It can be shown that this procedure yields prediction intervals that in the long run cover the true observations the desired proportion of the time.</p>
<p>The main tuning parameter of the original ACI algorithm is a learning rate that controls how fast prediction interval width changes. If the learning rate is too low, then the prediction intervals will not be able to adapt fast enough to shifts in the data generating distribution; if it is too large, then the intervals will oscillate widely. The critical dependence of the original ACI algorithm on proper choice of its learning rate spurred subsequent research into meta-algorithms that learn the correct learning rate (or an analogue thereof) in various ways, typically drawing on approaches from the online learning literature. In this paper, we present four such algorithms: Aggregated ACI <span class="citation" data-cites="zaffran2022agaci">(AgACI, <a href="#ref-zaffran2022agaci" role="doc-biblioref">Zaffran et al. 2022</a>)</span>, Fully Adaptive Conformal Inference <span class="citation" data-cites="gibbs2022faci">(FACI, <a href="#ref-gibbs2022faci" role="doc-biblioref">Gibbs and Candès 2022</a>)</span>, Scale-Free Online Gradient Descent <span class="citation" data-cites="bhatnagar2023saocp">(SF-OGD, <a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span>, and Strongly Adaptive Online Conformal Prediction <span class="citation" data-cites="bhatnagar2023saocp">(SAOCP, <a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span>. We note that the adaption of conformal inference techniques is an active area of research and the algorithms we focus on in this work are not exhaustive; see among others <span class="citation" data-cites="feldman2023achieving">Feldman et al. (<a href="#ref-feldman2023achieving" role="doc-biblioref">2023</a>)</span>, <span class="citation" data-cites="bastani2022practical">Bastani et al. (<a href="#ref-bastani2022practical" role="doc-biblioref">2022</a>)</span>, <span class="citation" data-cites="xu2021enbpi">Xu and Xie (<a href="#ref-xu2021enbpi" role="doc-biblioref">2021</a>)</span>, and <span class="citation" data-cites="xu2023spci">Xu and Xie (<a href="#ref-xu2023spci" role="doc-biblioref">2023</a>)</span>.</p>
<p>Our primary practical contribution is an implementation of each algorithm in an open source <code>R</code> package, <code>AdaptiveConformal</code>, which is available at <a href="https://github.com/herbps10/AdaptiveConformal">https://github.com/herbps10/AdaptiveConformal</a>. The package also includes routines for visualization and summary of the prediction intervals. We note that Python versions of several algorithms were also made available by <span class="citation" data-cites="zaffran2022agaci">Zaffran et al. (<a href="#ref-zaffran2022agaci" role="doc-biblioref">2022</a>)</span> and <span class="citation" data-cites="bhatnagar2023saocp">Bhatnagar et al. (<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">2023</a>)</span>, but to our knowledge this is the first package implementing them in <code>R</code>. In addition, several <code>R</code> packages exist for conformal inference in other contexts, including <code>conformalInference</code> focusing on regression <span class="citation" data-cites="tibshirani2019ci">(<a href="#ref-tibshirani2019ci" role="doc-biblioref">Tibshirani et al. 2019</a>)</span>, <code>conformalInference.fd</code>, with methods for functional responses <span class="citation" data-cites="diquigiovanni2022fd">(<a href="#ref-diquigiovanni2022fd" role="doc-biblioref">Diquigiovanni et al. 2022</a>)</span>, and <code>cfcausal</code> for causal inference related functionals <span class="citation" data-cites="lei2020cfcausal">(<a href="#ref-lei2020cfcausal" role="doc-biblioref">Lei and Candès 2020</a>)</span>. Our second practical contribution is to compare the performance of the algorithms in simulation studies and in a case study generating prediction intervals for influenza incidence in the United States based on black-box point forecasts.</p>
<p>The rest of the paper unfolds as follows. In <a href="#sec-theory">Section&nbsp;2</a>, we present a unified theoretical framework for analyzing the ACI algorithms based on the online learning paradigm. In <a href="#sec-algorithms">Section&nbsp;3</a> we provide descriptions of each algorithm along with their known theoretical properties. In <a href="#sec-simulations">Section&nbsp;4</a> we compare the performance of the algorithms in several simulation studies. <a href="#sec-case-study">Section&nbsp;5</a> gives a case study based on forecasting influenza in the United States. Finally, <a href="#sec-discussion">Section&nbsp;6</a> provides a discussion and ideas for future research in this rapidly expanding field.</p>
</section>
<section id="sec-theory" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Theoretical Framework</h1>
<p><em>Notation</em>: for any integer <span class="math inline">N \geq 1</span> let <span class="math inline">\llbracket N \rrbracket := \{ 1, \dots, N \}</span>. Let <span class="math inline">\mathbb{I}</span> be the indicator function. Let <span class="math inline">\nabla f</span> denote the gradient (subgradient) of the differentiable (convex) function <span class="math inline">f</span>.</p>
<p>We consider an online learning scenario in which we gain access to a sequence of observations <span class="math inline">(y_t)_{t \geq 1}</span> one at a time (see <span class="citation" data-cites="cesabianchi2006games">Cesa-Bianchi and Lugosi (<a href="#ref-cesabianchi2006games" role="doc-biblioref">2006</a>)</span> for an comprehensive account of online learning theory). Fix <span class="math inline">\alpha \in (0, 1)</span> to be the target empirical coverage of the prediction intervals. The goal is to output at time <span class="math inline">t</span> a prediction interval for the unseen observation <span class="math inline">y_{t}</span>, with the prediction interval generated by an <em>interval construction function</em> <span class="math inline">\widehat{C}_{t}</span>. Formally, let <span class="math inline">\widehat{C}_t</span> be a function that takes as input a parameter <span class="math inline">\theta_t \in \mathbb{R}</span> and outputs a closed prediction interval <span class="math inline">[\ell_t, u_t]</span>. The interval construction function must be nested: if <span class="math inline">\theta^\prime &gt; \theta</span>, then <span class="math inline">\widehat{C}_t(\theta) \subseteq \widehat{C}_t(\theta^\prime)</span>. In words, larger values of <span class="math inline">\theta</span> imply wider prediction intervals. The interval constructor is indexed by <span class="math inline">t</span> to emphasize that it may use other information at each time point, such as a point prediction <span class="math inline">\hat{\mu}_t \in \mathbb{R}</span>. We make no restrictions on how this external information is generated.</p>
<p>Define <span class="math inline">r_t := \inf\{\theta \in \mathbb{R} : \mathbb{I}(y_t \in \widehat{C}_t(\theta)) \}</span> to be the <em>radius</em> at time <span class="math inline">t</span>. The radius is the smallest possible <span class="math inline">\theta</span> such that the prediction interval covers the observation <span class="math inline">y_t</span>. A key assumption for the theoretical analysis of several of the algorithms is that the radii are bounded:</p>
<p><strong>Assumption</strong>: there exists a <span class="math inline">D &gt; 0</span> such that <span class="math inline">r_t &lt; D</span> for all <span class="math inline">t</span>.</p>
<p>Next, we describe two existing definitions of interval construction functions.</p>
<section id="linear-intervals" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="linear-intervals"><span class="header-section-number">2.1</span> Linear Intervals</h2>
<p>A simple method for forming the prediction intervals is to use the parameter <span class="math inline">\theta_t</span> to directly define the width of the interval. Suppose that at each time <span class="math inline">t</span> we have access to a point prediction <span class="math inline">\hat{\mu}_t \in \mathbb{R}</span>. Then we can form a symmetric prediction interval around the point estimate using <span class="math display">
\begin{aligned}
  \theta \mapsto \widehat{C}_t(\theta) := [\hat{\mu}_t - \theta, \hat{\mu}_t + \theta].
\end{aligned}
</span> We refer to this as the <em>linear interval constructor</em>. Note that in this case, the radius is simply the absolute residual <span class="math inline">r_t = |\hat{\mu}_t - y_t|</span>.</p>
</section>
<section id="quantile-intervals" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="quantile-intervals"><span class="header-section-number">2.2</span> Quantile Intervals</h2>
<p>The original ACI paper proposed constructing intervals based on the previously observed residuals <span class="citation" data-cites="gibbs2021adaptive">(<a href="#ref-gibbs2021adaptive" role="doc-biblioref">Gibbs and Candès 2021</a>)</span>. Let <span class="math inline">S : \mathbb{R}^2 \to \mathbb{R}</span> be a function called a <em>nonconformity score</em>. A popular choice of nonconformity score is the absolute residual: <span class="math inline">(\mu, y) \mapsto S(\mu, y):= |\mu - y|</span>. Let <span class="math inline">s_t := S(\hat{\mu}_t, y_t)</span> be the nonconformity score of the <span class="math inline">t</span>th-observation. The quantile interval construction function is then given by <span class="math display">
\begin{aligned}
  \widehat{C}_t(\theta_t) := [\hat{\mu}_t - \mathrm{Quantile}(\theta, \{ s_1, \dots, s_{t-1} \}), \hat{\mu}_t + \mathrm{Quantile}(\theta, \{ s_1, \dots, s_{t-1} \})]
\end{aligned}
</span> where <span class="math inline">\mathrm{Quantile}(\theta, A)</span> denotes the empirical <span class="math inline">\theta</span>-quantile of the elements in the set <span class="math inline">A</span>. Note that <span class="math inline">\widehat{C}_t</span> is indeed nested in <span class="math inline">\theta_t</span> because the Quantile function is non-decreasing in <span class="math inline">\theta</span>.</p>
<p>Our proposed <code>AdaptiveConformal</code> package takes the absolute residual as the default nonconformity score, although the user may also specify any custom nonconformity score by supplying it as an <code>R</code> function.</p>
</section>
<section id="online-learning-framework" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="online-learning-framework"><span class="header-section-number">2.3</span> Online Learning Framework</h2>
<p>We now introduce a loss function that defines the quality of a prediction interval with respect to a realized observation. Define the <em>pinball loss</em> <span class="math inline">L^\alpha</span> as <span class="math display">
(\theta, r) \mapsto L^\alpha(\theta, r) := \begin{cases}
  \alpha(\theta - r), &amp; \theta \geq r \\
  (1-\alpha)(r - \theta), &amp; \theta &lt; r.
\end{cases}
</span> The way in which the algorithm gains access to the data and incurs losses is as follows:</p>
<ul>
<li>Sequentially, for <span class="math inline">t = 1, \dots, T</span>:
<ul>
<li>Predict radius <span class="math inline">\theta_t</span> and form prediction interval <span class="math inline">\widehat{C}_t(\theta_t)</span>.</li>
<li>Observe true outcome <span class="math inline">y_t</span> and calculate radius <span class="math inline">r_t</span>.</li>
<li>Record <span class="math inline">\mathrm{err}_t := \mathbb{I}[y_t \not\in \widehat{C}_t(\theta_t)]</span>.</li>
<li>Incur loss <span class="math inline">L^\alpha(\theta_t, r_t)</span>.</li>
</ul></li>
</ul>
<p>This iterative procedure is at the core of the online learning theoretical framework in which theoretical results have been derived.</p>
</section>
<section id="assessing-aci-algorithms" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="assessing-aci-algorithms"><span class="header-section-number">2.4</span> Assessing ACI algorithms</h2>
<p>There are two different perspectives we can take in measuring the quality of an ACI algorithm that generates a sequence <span class="math inline">(\theta_t)_{t \in \llbracket T \rrbracket}</span>. First, we could look at how close the empirical coverage of the generated prediction intervals is to the desired coverage level <span class="math inline">\alpha</span>. Formally, define the empirical coverage as the proportion of observations that fell within the corresponding prediction interval: <span class="math inline">\mathrm{EmpCov}(T) := \frac{1}{T} \sum_{t=1}^T (1 - \mathrm{err}_t)</span>. The coverage error is then given by <span class="math display">
\begin{aligned}
  \mathrm{CovErr}(T) := \mathrm{EmpCov}(T) - \alpha.
\end{aligned}
</span> The second perspective is to look at how well the algorithm controls the incurred pinball losses. Following the classical framework from the online learning literature, we define the <em>regret</em> as the difference between the cumulative loss yielded by a sequence <span class="math inline">(\theta_t)_{t \in \llbracket T \rrbracket}</span> versus the cumulative loss of the best possible fixed choice: <span class="math display">
\begin{aligned}
  \mathrm{Reg}(T) := \sum_{t=1}^T L^\alpha(\theta_t, r_t) - \inf_{\theta^* \in \mathbb{R}} \sum_{t=1}^T L^\alpha(\theta^*, r_t).
\end{aligned}
</span> In settings of distribution shift, it may not be appropriate to compare the cumulative loss of an algorithm to a fixed competitor. As such, stronger notions of regret have been defined. The <em>strongly adaptive regret</em> is the largest regret over any subperiod of length <span class="math inline">k \in \llbracket T \rrbracket</span>: <span class="math display">
\begin{aligned}
  \mathrm{SAReg}(T, m) := \max_{[\tau, \tau + m - 1] \subseteq \llbracket T \rrbracket} \left( \sum_{t=\tau}^{\tau + m - 1} L^{\alpha}(\theta_t, r_t) - \inf_{\theta^* \in \mathbb{R}} \sum_{t=\tau}^{\tau + m - 1} L^\alpha(\theta^*, r_t) \right).
\end{aligned}
</span> Both ways of evaluating ACI methods are important because targeting only one or the other can lead to algorithms that yield prediction intervals that are not practically useful. As a simple pathological example of only targeting the coverage error, suppose we wish to generate <span class="math inline">\alpha = 50\%</span> prediction intervals. We could choose to alternate <span class="math inline">\theta</span> between 0 and <span class="math inline">\infty</span>, such that <span class="math inline">\mathrm{err}_t</span> alternates between 0 and 1. The empirical coverage would then trivially converge to the desired level of 50%. However, the same algorithm would yield infinite regret (see <span class="citation" data-cites="bhatnagar2023saocp">Bhatnagar et al. (<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">2023</a>)</span> for a more in-depth example of an scenario in which coverage is optimal but the regret grows linearly). On the other hand, an algorithm that has arbitrarily small regret may not yield good empirical coverage. Suppose the observations and point predictions are constant: <span class="math inline">y_t = 1</span> and <span class="math inline">\hat{\mu}_t = 0</span> for all <span class="math inline">t \geq 1</span>. Consider a simple class of algorithms that outputs constantly <span class="math inline">\theta_t = \theta'</span> for some <span class="math inline">\theta' &lt; 1</span>. With the linear interval construction function, the prediction intervals are then <span class="math inline">\widehat{C}_t(\theta_t) = [-\theta', \theta']</span>. The regret is given by <span class="math inline">\mathrm{Reg}(T) = 2T\alpha(1-\theta')</span>, which approaches zero as <span class="math inline">\theta'</span> approaches 1. The empirical coverage is, however, always zero. In other words, the regret can be arbitrarily close to zero while at the same time the empirical coverage does not approach the desired level.</p>
<p>These simple examples illustrate that, unfortunately, bounds on the coverage error and bounds on the regret are not in general interchangeable. It is possible, however, to show equivalencies by either (1) making distributional assumptions on the data or (2) using additional information about how the algorithm produces the sequence <span class="math inline">(\theta_t)_{t \in \llbracket T \rrbracket}</span> <span class="citation" data-cites="bhatnagar2023saocp">(<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span>.</p>
<p>It may also be informative to summarize a set of prediction intervals in ways beyond their coverage error or their regret. A common metric for prediction intervals is the <em>mean interval width</em>: <span class="math display">
\begin{aligned}
  \mathrm{MeanWidth}(T) := \frac{1}{T} \sum_{t=1}^T w_t,
\end{aligned}
</span> where <span class="math inline">w_t := u_t - \ell_t</span> is the interval width at time <span class="math inline">t</span>.</p>
<p>Finally, we introduce a metric that is intended to capture pathological behavior that can arise with ACI algorithms where the prediction intervals oscillate between being extremely narrow and extremely wide. Define the <em>path length</em> of prediction intervals generated by an ACI algorithm as <span class="math display">
\begin{aligned}
  \mathrm{PathLength}(T) := \sum_{t=2}^T |w_t - w_{t-1}|.
\end{aligned}
</span> A high path length indicates that the prediction intervals were variable over time, and a low path length indicates the prediction intervals were stable.</p>
</section>
</section>
<section id="sec-algorithms" class="level1" data-number="3">
<h1 data-number="3"><span class="header-section-number">3</span> Algorithms</h1>
<div id="tbl-aci" class="anchored">
<table class="table">
<caption>Table&nbsp;1: Summary of ACI algorithms</caption>
<colgroup>
<col style="width: 39%">
<col style="width: 44%">
<col style="width: 15%">
</colgroup>
<thead>
<tr class="header">
<th>Algorithm</th>
<th>Tuning Parameters</th>
<th>Original interval constructor</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Adaptive Conformal Inference (ACI)</td>
<td>Learning rate <span class="math inline">\gamma</span></td>
<td>Quantile</td>
</tr>
<tr class="even">
<td>Aggregated Adaptive Conformal Inference (AgACI)</td>
<td>Candidate learning rates <span class="math inline">(\gamma_k)_{1 \leq k \leq K}</span></td>
<td>Quantile</td>
</tr>
<tr class="odd">
<td>Fully Adaptive Conformal Inference (FACI)</td>
<td>Candidate learning rates <span class="math inline">(\gamma_k)_{1 \leq k \leq K}</span></td>
<td>Quantile</td>
</tr>
<tr class="even">
<td>Scale-Free Online Gradient Descent (SF-OGD)</td>
<td>Learning rate <span class="math inline">\gamma</span> or maximum radius <span class="math inline">D</span></td>
<td>Linear</td>
</tr>
<tr class="odd">
<td>Strongly Adaptive Online Conformal Prediction (SAOCP)</td>
<td>Learning rate <span class="math inline">\gamma</span>, lifetime multiplier <span class="math inline">g</span></td>
<td>Linear</td>
</tr>
</tbody>
</table>
</div>
<p>As a simple running example to illustrate each algorithm, we simulate independently <span class="math inline">T = 500</span> values <span class="math inline">y_1, \dots, y_T</span> following <span class="math display">
y_t \sim N(0, 0.2^2), \quad t \in \llbracket T \rrbracket.
</span> For demonstration purposes we assume we have access to unbiased predictions <span class="math inline">\hat{\mu}_t = 0</span> for all <span class="math inline">t \in \llbracket T \rrbracket</span>. Throughout we set the target empirical coverage to <span class="math inline">\alpha = 0.8</span>.</p>
<section id="adaptive-conformal-inference-aci" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="adaptive-conformal-inference-aci"><span class="header-section-number">3.1</span> Adaptive Conformal Inference (ACI)</h2>
<div id="algo-aci" class="pseudocode-container" data-alg-title="Algorithm" data-line-number-punc=":" data-line-number="true" data-comment-delimiter="//" data-no-end="false" data-pseudocode-index="1" data-indent-size="1.2em">
<div class="pseudocode">
\begin{algorithm} \caption{Adaptive Conformal Inference} \begin{algorithmic} \State \textbf{Input:} starting value $\theta_1$, learning rate $\gamma &gt; 0$. \For{$t = 1, 2, \dots, T$} \State \textbf{Output:} prediction interval $\widehat{C}_t(\theta_t)$. \State Observe $y_t$. \State Evaluate $\mathrm{err}_t = \mathbb{I}[y_t \not\in \widehat{C}_t(\theta_t)]$. \State Update $\theta_{t+1} = \theta_t + \gamma (\mathrm{err}_t - (1 - \alpha))$. \EndFor \end{algorithmic} \end{algorithm}
</div>
</div>
<p>The original ACI algorithm (<span class="citation" data-cites="gibbs2021adaptive">Gibbs and Candès (<a href="#ref-gibbs2021adaptive" role="doc-biblioref">2021</a>)</span>; <a href="#algo-aci">Algorithm 1</a>) adaptively adjusts the width of the prediction intervals in response to the observations. The updating rule for the estimated radius can be derived as an online subgradient descent scheme. The subgradient of the pinball loss function with respect to <span class="math inline">\theta</span> is given by <span class="math display">
\begin{aligned}
  \nabla L^\alpha(\theta, r) &amp;= \begin{cases}
    \{ -\alpha \}, &amp;\theta &lt; r, \\
    \{ 1 - \alpha \}, &amp; \theta &gt; r, \\
    [-\alpha, 1 - \alpha], &amp;\theta = r
  \end{cases} \\
\end{aligned}
</span> It follows that, for all <span class="math inline">\theta_t \in \mathbb{R}</span> and <span class="math inline">r_t \in \mathbb{R}</span>, <span class="math display">
1 - \alpha - \mathrm{err}_t \in \nabla L^\alpha(\theta_t, r_t).
</span> This leads to the following update rule for <span class="math inline">\theta</span> based on subgradient descent: <span class="math display">
\begin{aligned}
  \theta_{t+1} = \theta_{t} + \gamma (\mathrm{err}_t - (1 - \alpha)),
\end{aligned}
</span> where <span class="math inline">\gamma &gt; 0</span> is a user-specified learning rate. For intuition, note that if <span class="math inline">y_t</span> fell outside of the prediction interval at time <span class="math inline">t</span> (<span class="math inline">\mathrm{err}_t = 1</span>) then the next interval is widened (<span class="math inline">\theta_{t+1} = \theta_t + \gamma \alpha</span>). On the contrary, if <span class="math inline">y_t</span> fell within the interval (<span class="math inline">\mathrm{err}_t = 0</span>) then the next interval is shortened (<span class="math inline">\theta_{t+1} = \theta_t - \gamma(1 - \alpha)</span>). The learning rate <span class="math inline">\gamma</span> controls how fast the width of the prediction intervals changes in response to the data.</p>
<section id="theoretical-guarantees" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="theoretical-guarantees"><span class="header-section-number">3.1.1</span> Theoretical Guarantees</h3>
<p>The ACI algorithm has the following finite sample bound on the coverage error <span class="citation" data-cites="gibbs2021adaptive">(<a href="#ref-gibbs2021adaptive" role="doc-biblioref">Gibbs and Candès 2021</a>)</span>. For all <span class="math inline">\gamma &gt; 0</span>, <span class="math display">
|\mathrm{CovErr}(T)| \leq \frac{D + \gamma}{\gamma T}.
</span> This result was originally shown for ACI with the choice of the quantile interval constructor, although it can also be extended to other interval constructors <span class="citation" data-cites="bhatnagar2023saocp">Feldman et al. (<a href="#ref-feldman2023achieving" role="doc-biblioref">2023</a>)</span>. In addition, standard results for online subgradient descent yield the following regret bound with the use of the linear interval constructor, assuming that the true radii are bounded by <span class="math inline">D</span>: <span class="math display">
\mathrm{Reg}(T) \leq \mathcal{O}(D^2 / \gamma + \gamma T) \leq \mathcal{O}(D \sqrt{T}),
</span> where the second inequality follows if the optimal choice of <span class="math inline">\gamma = D/\sqrt{T}</span> is used <span class="citation" data-cites="bhatnagar2023saocp">(<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span>. Taken together, these theoretical results imply that while the coverage error is guaranteed to converge to zero for any choice of <span class="math inline">\gamma</span>, achieving sublinear regret requires choosing <span class="math inline">\gamma</span> more carefully. This highlights the importance of both ways of assessing ACI algorithms: if we only focused on controlling the coverage error, we might not achieve optimal control of regret, leading to intervals that are not practically useful.</p>
</section>
<section id="tuning-parameters" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="tuning-parameters"><span class="header-section-number">3.1.2</span> Tuning Parameters</h3>
<p>Therefore, the main tuning parameter is the learning rate <span class="math inline">\gamma</span>. The theoretical bounds on the coverage error suggest setting a large <span class="math inline">\gamma</span> such that the coverage error decays quickly in <span class="math inline">T</span>; however, in practice and setting <span class="math inline">\gamma</span> too large will lead to intervals with large oscillations as seen in <a href="#fig-aci">Figure&nbsp;1</a>. This is quantified in the path length, which increases significantly as <span class="math inline">\gamma</span> increases, even though the empirical coverage remains near the desired value of 80%. On the other hand, setting <span class="math inline">\gamma</span> too small will lead to intervals that do not adapt fast enough to distribution shifts. Thus, choosing a good value for <span class="math inline">\gamma</span> is essential. However, the optimal choice <span class="math inline">\gamma = D / \sqrt{T}</span> cannot be used directly in practice unless the time series length <span class="math inline">T</span> is fixed in advance, or the so called “doubling trick” is used to relax the need to know <span class="math inline">T</span> in advance <span class="citation" data-cites="cesabianchi2006games">(<a href="#ref-cesabianchi2006games" role="doc-biblioref">Cesa-Bianchi and Lugosi 2006</a>)</span>.</p>
<p>The theoretical results guaranteeing the performance of the ACI algorithm do not depend on the choice of starting value <span class="math inline">\theta_1</span>, and thus in practice any value can be chosen. Indeed, the effect of the choice of <span class="math inline">\theta_1</span> decays over time as a function of the chosen learning rate. In practice, substantive prior information can be used to pick a reasonable starting value. By default, the <code>AdaptiveConformal</code> package sets <span class="math inline">\theta_1 = \alpha</span> when the quantile interval predictor is used, and <span class="math inline">\theta_1 = 0</span> otherwise, although in both cases the user can supply their own starting value. The behavior of the early prediction intervals in the examples (<a href="#fig-aci">Figure&nbsp;1</a>) is driven by the small number of residuals available, which makes the output of the quantile interval constructor sensitive to small changes in <span class="math inline">\theta</span>. In practice, a warm-up period can be used before starting to produce prediction intervals so that the quantiles of the residuals are more stable.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-aci" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-aci-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;1: Example 80% prediction intervals from the ACI algorithm for different choices of learning rate <span class="math inline">\gamma</span> and with <span class="math inline">\theta_1 = 0.8</span>. Blue and red points are observations that fell inside and outside the prediction intervals, respectively.</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="aggregated-adaptive-conformal-inference-agaci" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="aggregated-adaptive-conformal-inference-agaci"><span class="header-section-number">3.2</span> Aggregated Adaptive Conformal Inference (AgACI)</h2>
<div id="algo-agaci" class="pseudocode-container" data-alg-title="Algorithm" data-line-number-punc=":" data-line-number="true" data-comment-delimiter="//" data-no-end="false" data-pseudocode-index="2" data-indent-size="1.2em">
<div class="pseudocode">
\begin{algorithm} \caption{Aggregated Adaptive Conformal Inference} \begin{algorithmic} \State \textbf{Input:} candidate learning rates $(\gamma_k)_{1 \leq k \leq K }$, starting value $\theta_1$. \State Initialize lower and upper BOA algorithms $\mathcal{B}^\ell := \texttt{BOA}(\alpha \leftarrow (1 - \alpha) / 2)$ and $\mathcal{B}^u := \texttt{BOA}(\alpha \leftarrow (1 - (1 - \alpha)/2))$. \For{$k = 1, \dots, K$} \State Initialize ACI $\mathcal{A}_k = \texttt{ACI}(\alpha \leftarrow \alpha, \gamma \leftarrow \gamma_k, \theta_1 \leftarrow \theta_1)$. \EndFor \For{$t = 1, 2, \dots, T$} \For{$k = 1, \dots, K$} \State Retrieve candidate prediction interval $[\ell^k_{t}, u^k_{t}]$ from $\mathcal{A}_k$. \EndFor \State Compute aggregated lower bound $\tilde{\ell}_t := \mathcal{B}^\ell((\ell^k_t : k \in \{ 1, \dots, K \}))$. \State Compute aggregated upper bound $\tilde{u}_t := \mathcal{B}^u((u^k_t : k \in \{ 1, \dots, K \}))$. \State \textbf{Output:} prediction interval $[\tilde{\ell}_t, \tilde{u}_t]$. \State Observe $y_t$. \For{$k = 1, \dots, K$} \State Update $\mathcal{A}_k$ with observation $y_t$. \EndFor \State Update $\mathcal{B}^\ell$ with observed outcome $y_t$. \State Update $\mathcal{B}^u$ with observed outcome $y_t$. \EndFor \end{algorithmic} \end{algorithm}
</div>
</div>
<p>The Aggregated ACI (AgACI; <a href="#algo-agaci">Algorithm 2</a>) algorithm solves the problem of choosing a learning rate for ACI by running multiple copies of the algorithm with different learning rates, and then separately combining the lower and upper interval bounds using an online aggregation of experts algorithm <span class="citation" data-cites="zaffran2022agaci">(<a href="#ref-zaffran2022agaci" role="doc-biblioref">Zaffran et al. 2022</a>)</span>. That is, one aggregation algorithm seeks to estimate the lower <span class="math inline">(1-\alpha)/2</span> quantile, and the other seeks to estimate the upper <span class="math inline">1 - (1 - \alpha) / 2</span> quantile. <span class="citation" data-cites="zaffran2022agaci">Zaffran et al. (<a href="#ref-zaffran2022agaci" role="doc-biblioref">2022</a>)</span> experimented with multiple online aggregation algorithms, and found that they yielded similar results. Thus, we follow their lead in using the Bernstein Online Aggregation (BOA) algorithm as implemented in the <code>opera</code> <code>R</code> package <span class="citation" data-cites="wintenberger2017boa opera2023">(<a href="#ref-wintenberger2017boa" role="doc-biblioref">Wintenberger 2017</a>; <a href="#ref-opera2023" role="doc-biblioref">Gaillard et al. 2023</a>)</span>. BOA is an online algorithm that forms predictions for the lower (or upper) prediction interval bound as a weighted mean of the candidate ACI prediction interval lower (upper) bound, where the weights are determined by each candidate’s past performance with respect to the quantile loss. As a consequence, the prediction intervals generated by AgACI are not necessarily symmetric around the point prediction, as the weights for the lower and upper bounds are separate.</p>
<section id="theoretical-gaurantees" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="theoretical-gaurantees"><span class="header-section-number">3.2.1</span> Theoretical Gaurantees</h3>
<p>AgACI departs from our main theoretical framework in that it does not yield a sequence <span class="math inline">(\theta_t)_{t \in \llbracket T \rrbracket}</span> whose elements yield prediction intervals via a set construction function <span class="math inline">\widehat{C}_t</span>. Rather, the upper and lower interval bounds from a set of candidate ACI algorithms are aggregated separately. Thus, theoretical results such as regret bounds similar to those for the other algorithms are not available. It would be possible, however, to establish regret bounds for the pinball loss applied separately to the lower and upper bounds of the prediction intervals. It is unclear, however, how to convert such regret bounds into a coverage bound.</p>
</section>
<section id="tuning-parameters-1" class="level3" data-number="3.2.2">
<h3 data-number="3.2.2" class="anchored" data-anchor-id="tuning-parameters-1"><span class="header-section-number">3.2.2</span> Tuning Parameters</h3>
<p>The main tuning parameter for AgACI is the set of candidate learning rates. Beyond necessitating additional computational time, there is no drawback to having a large grid. As a default, <code>AdaptiveConformal</code> uses learning rates <span class="math inline">\gamma \in \{ 0.001, 0.002, 0.004, 0.008, 0.016, 0.032, 0.064, 0.128 \}</span>. As a basic check, we can look at the weights assigned to each of the learning rates. If large weights are given to the smallest (largest) learning rates, it is a sign that smaller (or larger) learning rates may perform well. In addition each of the candidate ACI algorithms requires a starting value, which can be set to any value as discussed in the ACI section. <a href="#fig-agaci">Figure&nbsp;2</a> illustrates AgACI applied to the running example with two sets of learning grids. The first grid is the default, and the second grid includes the additional value <span class="math inline">\gamma = \{ 0.0005 \}</span>. For the first grid, we can see that for the lower bound AgACI assigns high weight to the lowest learning rate (<span class="math inline">\gamma = 0.001</span>). Based on this observation, as a sensitivity check, we reran the algorithm with the second learning grid, which yields weights that are less concentrated on a single learning rate. The output prediction intervals are similar, although slightly smoother in the second grid, reflecting the lack of distributional shift in the simulated data.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-agaci" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-agaci-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;2: Example 80% prediction intervals from the AgACI algorithm with starting values <span class="math inline">\theta_1 = 0.8</span> and two different learning rate grids, where the second grid is double the size of the first. In the left column, blue and red points are observations that fell inside and outside the prediction intervals, respectively.</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="fully-adaptive-conformal-inference-faci" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="fully-adaptive-conformal-inference-faci"><span class="header-section-number">3.3</span> Fully Adaptive Conformal Inference (FACI)</h2>
<div id="algo-faci" class="pseudocode-container" data-alg-title="Algorithm" data-line-number-punc=":" data-line-number="true" data-comment-delimiter="//" data-no-end="false" data-pseudocode-index="3" data-indent-size="1.2em">
<div class="pseudocode">
\begin{algorithm} \caption{Fully Adaptive Conformal Inference} \begin{algorithmic} \State \textbf{Input:} starting value $\theta_1$, candidate learning rates $(\gamma_k)_{1 \leq k \leq K }$, parameters $\sigma, \eta$. \For{$k = 1, \dots, K$} \State Initialize expert $\mathcal{A}_k = \texttt{ACI}(\alpha \leftarrow \alpha, \gamma \leftarrow \gamma_k, \theta_1 \leftarrow \theta_1)$. \EndFor \For{$t = 1, 2, \dots, T$} \State Define $p_t^k := w_t^k / \sum_{i=1}^K w_t^i$, for all $1 \leq k \leq K$. \State Set $\theta_t = \sum_{k=1}^K \theta_t^k p_t^k$. \State \textbf{Output:} prediction interval $\widehat{C}_t(\theta_t)$. \State Observe $y_t$ and compute $r_t$. \State $\bar{w}_{t}^k \gets w_t^k \exp(-\eta L^\alpha(\theta_t^k, r_t))$, for all $1 \leq k \leq K$. \State $\bar{W}_t \gets \sum_{i=1}^K \bar{w}_t^i$. \State $w_{t+1}^k \gets (1 - \sigma) \bar{w}_t^k + \bar{W}_t \sigma / K$. \State Set $\mathrm{err}_t := \mathbb{I}[y_t \not\in \widehat{C}_t(\theta_t)]$. \For{$k = 1, \dots, K$} \State Update ACI $\mathcal{A}_k$ with $y_t$ and obtain $\theta_{t+1}^k$. \EndFor \EndFor \end{algorithmic} \end{algorithm}
</div>
</div>
<p>The Fully Adaptive Conformal Inference (FACI; <a href="#algo-faci">Algorithm 3</a>) algorithm was developed by the authors of the original ACI algorithm in part to address the issue of how to choose the learning rate parameter <span class="math inline">\gamma</span>. In this respect the goal of the algorithm is similar to that of AgACI, although it is achieved slightly differently. FACI also aggregates predictions from multiple copies of ACI run with different learning rates, but differs in that it directly aggregates the estimated radii emitted from each algorithm based on their pinball loss <span class="citation" data-cites="gibbs2022faci">(<a href="#ref-gibbs2022faci" role="doc-biblioref">Gibbs and Candès 2022</a>)</span> using an exponential reweighting scheme <span class="citation" data-cites="gradu2022adaptive">(<a href="#ref-gradu2022adaptive" role="doc-biblioref">Gradu, Hazan, and Minasyan 2022</a>)</span>. As opposed to AgACI, this construction allows for more straightforward development of theoretical guarantees on the algorithm’s performance, because the upper and lower bounds of the intervals are not aggregated separately.</p>
<section id="theoretical-guarantees-1" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="theoretical-guarantees-1"><span class="header-section-number">3.3.1</span> Theoretical Guarantees</h3>
<p>FACI was originally proposed with the choice of the quantile interval constructor. FACI has the following strongly-adaptive regret bound <span class="citation" data-cites="bhatnagar2023saocp">(<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span>: for all <span class="math inline">\gamma &gt; 0</span> and subperiod lengths <span class="math inline">m</span>, <span class="math display">
\begin{aligned}
  \mathrm{SAReg}(T, m) \leq \widetilde{\mathcal{O}}(D^2 / \gamma + \gamma m).
\end{aligned}
</span> If <span class="math inline">m</span> is fixed a-priori, then choosing <span class="math inline">\gamma = D/\sqrt{m}</span> yields a strongly adaptive regret bound of order <span class="math inline">\widetilde{\mathcal{O}}(D \sqrt{m})</span> (for a single choice of <span class="math inline">m</span>). Practically, this result implies that, if we know in advance the time length for which we would like to control the regret, it is possible to choose an optimal tuning parameter value. However, we cannot control the regret simultaneously for all possible time lengths.</p>
<p>To establish a bound on the coverage error, the authors investigated a slightly modified version of FACI in which <span class="math inline">\theta_t</span> is chosen randomly from the candidate <span class="math inline">\theta_{t_k}</span> with weights given by <span class="math inline">p_{t,k}</span>, instead of taking a weighted average. This is a common trick used in the literature as it facilitates theoretical analysis. In practice, the authors comment that this randomized version of FACI and the deterministic version lead to very similar results. The coverage error result also assumes that the hyperparameters can change over time: that is, we have <span class="math inline">t</span>-specific <span class="math inline">\eta_{t}</span> and <span class="math inline">\sigma_t</span>, rather than fixed <span class="math inline">\eta</span> and <span class="math inline">\sigma</span>. The coverage error then has the following bound <span class="citation" data-cites="gibbs2022faci">(<a href="#ref-gibbs2022faci" role="doc-biblioref">Gibbs and Candès 2022</a>)</span>, where <span class="math inline">\gamma_{\min}</span> and <span class="math inline">\gamma_{\max}</span> are the smallest and largest learning rates in the grid, respectively: <span class="math display">
|\mathrm{CovErr}(T)| \leq \frac{1 + 2\gamma_{\max}}{T \gamma_{\min}} + \frac{(1 + 2\gamma_{\max})^2}{\gamma_{\min}} \exp(\eta_t(1 + 2\gamma_{\max})) \frac{1}{T}\sum_{t=1}^T \eta_t + 2 \frac{1+\gamma_{\max}}{\gamma_{\min}} \frac{1}{T} \sum_{t=1}^T \sigma_t.
</span> Thus, if <span class="math inline">\eta_t</span> and <span class="math inline">\sigma_t</span> both converge to zero as <span class="math inline">t \to \infty</span>, then the coverage error will also converge to zero. In addition, under mild distributional assumptions the authors provide a type of short-term coverage error bound for arbitrary time spans, for which we refer to <span class="citation" data-cites="gibbs2022faci">(<a href="#ref-gibbs2022faci" role="doc-biblioref">Gibbs and Candès 2022</a>)</span>.</p>
<p>We note one additional result established by <span class="citation" data-cites="gibbs2022faci">Gibbs and Candès (<a href="#ref-gibbs2022faci" role="doc-biblioref">2022</a>)</span> on a slightly different regret bound in terms of the pinball loss, as it informs the choice of tuning parameters. Let <span class="math inline">\gamma_{\mathrm{max}} = \max_{1 \leq k \leq K} \gamma_k</span> be the largest learning rate in the grid and assume that <span class="math inline">\gamma_1 &lt; \gamma_2 &lt; \cdots &lt; \gamma_K</span> with <span class="math inline">\gamma_{k+1}/\gamma \leq 2</span> for all <span class="math inline">1 \leq k &lt; K</span>. Then, for any interval <span class="math inline">I = [r, s] \subseteq \llbracket T \rrbracket</span> and any sequence <span class="math inline">\theta_r^*, \dots, \theta_s^*</span>, under the assumption that <span class="math inline">\gamma_k \geq \sqrt{1 + 1 / |I|}</span>, <span class="math display">
\begin{aligned}
  \frac{1}{|I|} \sum_{t=r}^s \mathbb{E}[L^\alpha(\theta_t, r_t)] - \frac{1}{|I|} \sum_{t=r}^s L^\alpha(\theta_t, \theta_t^*) \leq&amp; \frac{\log(k / \sigma) + 2\sigma|I|}{\eta |I|} + \frac{\eta}{|I|} \sum_{t=r}^s \mathbb{E}[L^\alpha(\theta_t, r_t)^2] \\
  &amp;+ 2\sqrt{3}(1 + \gamma_{\mathrm{max}})^2 \max\left\{ \sqrt{\frac{\sum_{t=r+1}^s |\theta_t^* - \theta_{t-1}^*| + 1}{|I|}}, \gamma_1 \right\},
\end{aligned}
</span> where the expectation is over the randomness in the randomized version of the algorithm. Here the time interval <span class="math inline">I</span> (with length <span class="math inline">|I|</span>) is comparable to the time period length <span class="math inline">m</span> for the strongly adaptive regret. The parameter <span class="math inline">|I|</span>, the time interval of interest for which we would like to control, can be chosen arbitrarily.</p>
</section>
<section id="tuning-parameters-2" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="tuning-parameters-2"><span class="header-section-number">3.3.2</span> Tuning parameters</h3>
<p>The recommended settings for the tuning parameters depend on choosing a time interval length <span class="math inline">|I|</span> for which we would like to control the pinball loss. The choice of <span class="math inline">|I|</span> can be chosen arbitrarily. For the tuning parameter <span class="math inline">\sigma</span>, the authors suggest the optimal choice <span class="math inline">\sigma = 1 / (2 |I|)</span>. Choosing <span class="math inline">\eta</span> is more difficult. The authors suggest the following choice for <span class="math inline">\eta</span>, which they show is optimal if there is in fact no distribution shift: <span class="math display">
\begin{aligned}
  \eta = \sqrt{\frac{3}{|I|}} \sqrt{\frac{\log(K \cdot |I|) + 2}{(\alpha)^2 (1 - \alpha)^3 + (1-\alpha)^2 \alpha^3 }}
\end{aligned}.
</span> Note that this choice is optimal only for the quantile interval constructor, for which <span class="math inline">\theta_t</span> is a quantile of previous nonconformity scores. As an alternative, the authors point out that <span class="math inline">\eta</span> can be learned in an online fashion using the update rule <span class="math display">
\begin{aligned}
  \eta_t := \sqrt{\frac{\log(|I| K) + 2}{\sum_{s=t-|I|}^{t-1} L^\alpha(\theta_s, r_s)}}.
\end{aligned}
</span> Both ways of choosing <span class="math inline">\eta</span> led to very similar results in the original author’s empirical studies. In our proposed <code>AdaptiveConformal</code> package, the first approach is used when the quantile interval construction function is chosen, and the latter approach for the linear interval construction function.</p>
<p><a href="#fig-faci-example">Figure&nbsp;3</a> illustrates FACI with the quantile interval construction function and with the learning rate grid <span class="math inline">\gamma \in \{ 0.001, 0.002, 0.004, 0.008, 0.016, 0.032, 0.064, 0.128 \}</span>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-faci-example" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-faci-example-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;3: Example 80% prediction intervals generated by the FACI algorithm with starting values <span class="math inline">\theta_1 = 0.8</span>. Blue and red points are observations that fell inside and outside the prediction intervals, respectively.</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="scale-free-online-gradient-descent-sf-ogd" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="scale-free-online-gradient-descent-sf-ogd"><span class="header-section-number">3.4</span> Scale-Free Online Gradient Descent (SF-OGD)</h2>
<div id="algo-sfogd" class="pseudocode-container" data-alg-title="Algorithm" data-line-number-punc=":" data-line-number="true" data-comment-delimiter="//" data-no-end="false" data-pseudocode-index="4" data-indent-size="1.2em">
<div class="pseudocode">
\begin{algorithm} \caption{Scale-Free Online Gradient Descent} \begin{algorithmic} \State \textbf{Input:} starting value $\theta_1$, learning rate $\gamma &gt; 0$. \For{$t = 1, 2, \dots, T$} \State \textbf{Output:} prediction interval $\widehat{C}_t(\theta_t)$. \State Observe $y_t$ and compute $r_t$. \State Update $\theta_{t+1} = \theta_t - \gamma \frac{\nabla L^\alpha(\theta_t, r_t)}{\sqrt{\sum_{i=1}^t} \| \nabla L^\alpha(\theta_i, r_i) \|_2^2}$. \EndFor \end{algorithmic} \end{algorithm}
</div>
</div>
<p>Scale-Free Online Gradient Descent (SF-OGD; <a href="#algo-sfogd">Algorithm 4</a>) is a general algorithm for online learning proposed by <span class="citation" data-cites="orabona2018sfogd">Orabona and Pál (<a href="#ref-orabona2018sfogd" role="doc-biblioref">2018</a>)</span>. The algorithm updates <span class="math inline">\theta_t</span> with a gradient descent step where the learning rate adapts to the scale of the previously observed gradients. SF-OGD was first used in the context of ACI as a sub-algorithm for SAOCP (described in the next section). However, it was found to have good performance by itself <span class="citation" data-cites="bhatnagar2023saocp">(<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span> in real-world tasks, so we have made it available in the package as a stand-alone algorithm.</p>
<section id="theoretical-guarantees-2" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="theoretical-guarantees-2"><span class="header-section-number">3.4.1</span> Theoretical Guarantees</h3>
<p>The SF-OGD algorithm with linear interval constructor has the following regret bound, which is called an <em>anytime regret bound</em> because it holds for all <span class="math inline">t \in \llbracket T \rrbracket</span> <span class="citation" data-cites="bhatnagar2023saocp">(<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span>. For any <span class="math inline">\gamma &gt; 0</span>, <span class="math display">
\begin{aligned}
  \mathrm{Reg}(t) \leq \mathcal{O}(D \sqrt{t}) \text{ for all } t \in \llbracket T \rrbracket.
\end{aligned}
</span> A bound for the coverage error has also been established <span class="citation" data-cites="bhatnagar2023saocp">(<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span>. For any learning rate <span class="math inline">\gamma = \Theta(D)</span> (where <span class="math inline">\gamma = D / \sqrt{3}</span> is optimal) and any starting value <span class="math inline">\theta_1 \in [0, D]</span>, then it holds that for any <span class="math inline">T &gt; 1</span>, <span class="math display">
\begin{aligned}
  |\mathrm{CovErr}(T)| \leq \mathcal{O}\left( (1 - \alpha)^{-2} T^{-1/4} \log T \right).
\end{aligned}
</span></p>
</section>
<section id="tuning-parameters-3" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="tuning-parameters-3"><span class="header-section-number">3.4.2</span> Tuning parameters</h3>
<p><a href="#fig-sf-ogd">Figure&nbsp;4</a> compares results for several choices of <span class="math inline">\gamma</span> to illustrate its effect. The optimal choice of learning rate is <span class="math inline">\gamma = D / \sqrt{3}</span>, where <span class="math inline">D</span> is the maximum possible radius. When <span class="math inline">D</span> is not known, it can be estimated by using an initial subset of the time series as a calibration set and estimating <span class="math inline">D</span> as the maximum of the absolute residuals of the observations and the predictions <span class="citation" data-cites="bhatnagar2023saocp">(<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span>. <a href="#fig-sf-ogd">Figure&nbsp;4</a> illustrates SF-OGD for several values of <span class="math inline">\gamma</span>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-sf-ogd" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-sf-ogd-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;4: Example 80% prediction intervals generated by the SF-OGD algorithm with different values of the maximum radius tuning parameter <span class="math inline">D</span>. Blue and red points are observations that fell inside and outside the prediction intervals, respectively.</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="strongly-adaptive-online-conformal-prediction-saocp" class="level2" data-number="3.5">
<h2 data-number="3.5" class="anchored" data-anchor-id="strongly-adaptive-online-conformal-prediction-saocp"><span class="header-section-number">3.5</span> Strongly Adaptive Online Conformal Prediction (SAOCP)</h2>
<div id="algo-saocp" class="pseudocode-container" data-alg-title="Algorithm" data-line-number-punc=":" data-line-number="true" data-comment-delimiter="//" data-no-end="false" data-pseudocode-index="5" data-indent-size="1.2em">
<div class="pseudocode">
\begin{algorithm} \caption{Strongly Adaptive Online Conformal Prediction} \begin{algorithmic} \State \textbf{Input:} initial value $\theta_0$, learning rate $\gamma &gt; 0$. \For{$t = 1, 2, \dots, T$} \State Initialize expert $\mathcal{A}_t = \texttt{SF-OGD}(\alpha \leftarrow \alpha, \gamma \leftarrow \gamma, \theta_1 \leftarrow \theta_{t-1})$, set weight $w_t^t = 0$. \State Compute active set $\mathrm{Active}(t) = \{ i \in \llbracket T \rrbracket : t - L(i) &lt; i \leq t \}$ (see below for definition of $L(t)$). \State Compute prior probability $\pi_i \propto i^{-2} (1 + \lfloor \log_2 i \rfloor )^{-1} \mathbb{I}[i \in \mathrm{Active}(t)]$. \State Compute un-normalized probability $\hat{p}_i = \pi_i [w_{t,i}]_+$ for all $i \in \llbracket t \rrbracket$. \State Normalize $p = \hat{p} / \| \hat{p} \|_1 \in \Delta^t$ if $\| \hat{p} \|_1 &gt; 0$, else $p = \pi$. \State Set $\theta_t = \sum_{i \in \mathrm{Active}(t)} p_i \theta_t^i$ (for $t \geq 2$), and $\theta_t = 0$ for $t = 1$. \State \textbf{Output:} prediction set $\widehat{C}_t(\theta_t)$. \State Observe $y_t$ and compute $r_t$. \For{$i \in \mathrm{Active}(t)$} \State Update expert $\mathcal{A}_t$ with $y_t$ and obtain $\theta_{t+1}^i$. \State Compute $g_t^i = \begin{cases} \frac{1}{D}\left(L^\alpha(\theta_t, r_t) - L^\alpha(\theta_t^i, r_t)\right) &amp; w_t^i &gt; 0 \\ \frac{1}{D}\left[L^\alpha(\theta_t, r_t) - L^\alpha(\theta_t^i, r_t))\right]_+ &amp; w_t^i \leq 0 \\ \end{cases}$. \State Update expert weight $w_{t+1}^i = \frac{1}{t - i + 1}\left( \sum_{j=i}^t g_j^i \right) \left(1 + \sum_{j=i}^t w_j^i g_j^i \right)$. \EndFor \EndFor \end{algorithmic} \end{algorithm}
</div>
</div>
<p>The Strongly Adaptive Online Conformal Prediction (SAOCP; <a href="#algo-saocp">Algorithm 5</a>) algorithm was proposed as an improvement over the extant ACI algorithms in that it features stronger theoretical guarantees. SAOCP works similarly to AgACI and FACI in that it maintains a library of candidate online learning algorithms that generate prediction intervals which are then aggregated using a meta-algorithm <span class="citation" data-cites="bhatnagar2023saocp">(<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span>. The candidate algorithm was chosen to be SF-OGD, although any algorithm that features anytime regret guarantees can be chosen. As opposed to AgACI and FACI, in which each candidate has a different learning rate but is always able to contribute to the final prediction intervals, here each candidate has the same learning rate but only has positive weight over a specific interval of time. New candidate algorithms are continually being spawned in order that, if the distribution shifts rapidly, the newer candidates will be able to react quickly and receive positive weight. Specifically, at each time point, a new expert is instantiated which is active over a finite ``lifetime”. Define the <em>lifetime</em> of an expert instantiated at time <span class="math inline">t</span> as <span class="math display">
\begin{aligned}
  L(t) := g \cdot \max_{n \in \mathbb{Z}} \{ 2^n t \equiv 0 \mod 2^n \},
\end{aligned}
</span> where <span class="math inline">g \in \mathbb{Z}^*</span> is a <em>lifetime multiplier</em> parameter. The active experts are weighted according to their empirical performance with respect to the pinball loss function. The authors show that this construction results in intervals that have strong regret guarantees.</p>
<section id="theoretical-guarantees-3" class="level3" data-number="3.5.1">
<h3 data-number="3.5.1" class="anchored" data-anchor-id="theoretical-guarantees-3"><span class="header-section-number">3.5.1</span> Theoretical Guarantees</h3>
<p>The theoretical results were established for SAOCP using the linear interval constructor. The following bound for the strongly adaptive regret holds for all subperiod lengths <span class="math inline">m \in \llbracket T \rrbracket</span> <span class="citation" data-cites="bhatnagar2023saocp">(<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span>: <span class="math display">
\begin{aligned}
  \mathrm{SAReg}(T, m) \leq 15 D \sqrt{m(\log T + 1)} \leq \tilde{\mathcal{O}}(D \sqrt m).
\end{aligned}
</span> It should be emphasized that this regret bounds holds simultaneously across all <span class="math inline">m</span>, as opposed to FACI, where a similar bound holds only for a single <span class="math inline">m</span>. A bound on the coverage error of SAOCP has also been established as: <span class="math display">
\begin{aligned}
  |\mathrm{CovErr}(T)| \leq \mathcal{O}\left(\inf_\beta(T^{1/2 - \beta} + T^{\beta - 1} S_\beta(T))\right).
\end{aligned}
</span> where <span class="math inline">S_{\beta}(T)</span> is a technical measure of the smoothness of the cumulative gradients and expert weights for each of the candidate experts <span class="citation" data-cites="bhatnagar2023saocp">(<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">Bhatnagar et al. 2023</a>)</span>.</p>
</section>
<section id="tuning-parameters-4" class="level3" data-number="3.5.2">
<h3 data-number="3.5.2" class="anchored" data-anchor-id="tuning-parameters-4"><span class="header-section-number">3.5.2</span> Tuning Parameters</h3>
<p>The main tuning parameter for SAOCP is the learning rate <span class="math inline">\gamma</span> of the SF-OGD sub-algorithms, which we saw in the previous section has for optimal choice <span class="math inline">\gamma = D / \sqrt{3}</span>. Values for <span class="math inline">D</span> that are too low lead to intervals that adapt slowly, and values that are too large lead to jagged intervals. In their experiments, the authors select a value for <span class="math inline">D</span> by picking the maximum residual from a calibration set. The second tuning parameter is the lifetime multiplier <span class="math inline">g</span> which controls the lifetime of each of the experts. We follow the original paper in setting <span class="math inline">g = 8</span>. <a href="#fig-saocp">Figure&nbsp;5</a> illustrates the SAOCP algorithm for choices of <span class="math inline">D \in \{0.01, 0.1, 0.25, 0.5 \}</span>.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-saocp" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-saocp-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;5: Example 80% prediction intervals generated by the SAOCP algorithm with different values of the maximum radius parameter <span class="math inline">D</span>. Blue and red points are observations that fell inside and outside the prediction intervals, respectively.</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
</section>
<section id="sec-simulations" class="level1" data-number="4">
<h1 data-number="4"><span class="header-section-number">4</span> Simulation Studies</h1>
<p>We present two empirical studies in order to compare the performance of the AgACI, FACI, SF-OGD, and SAOCP algorithms applied to simple simulated datasets. The original ACI algorithm was not included as it is not clear how to set the tuning rate <span class="math inline">\gamma</span>, which can have a large effect on the resulting intervals. For both simulations we set the targeted empirical coverage to <span class="math inline">\alpha = 0.8</span>, <span class="math inline">\alpha = 0.9</span>, and <span class="math inline">\alpha = 0.95</span>. For each algorithm, we chose the interval constructor that was used in its original presentation (see <a href="#tbl-aci">Table&nbsp;1</a>).</p>
<section id="time-series-with-arma-errors" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="time-series-with-arma-errors"><span class="header-section-number">4.1</span> Time series with ARMA errors</h2>
<p>In this simulation we reproduce the setup described in <span class="citation" data-cites="zaffran2022agaci">Zaffran et al. (<a href="#ref-zaffran2022agaci" role="doc-biblioref">2022</a>)</span> (itself based on that of <span class="citation" data-cites="friedman1983">Friedman, Grosse, and Stuetzle (<a href="#ref-friedman1983" role="doc-biblioref">1983</a>)</span>). The time series values <span class="math inline">y_t</span> for <span class="math inline">t \in \llbracket T \rrbracket</span> (<span class="math inline">T = 600</span>) are simulated according to <span class="math display">
\begin{aligned}
  y_t = 10\sin(\pi X_{t,1}X_{t,2}) + 20(X_{t,3} - 0.5)^2 + 10X_{t,4} + 5 X_{t,5} + 0X_{t,6} + \epsilon_t,
\end{aligned}
</span> where <span class="math inline">X_{t,i}</span>, <span class="math inline">i = 1, \dots, 6</span>, <span class="math inline">t \in \llbracket T \rrbracket</span> are independently uniformly distributed on <span class="math inline">[0, 1]</span> and the noise terms <span class="math inline">\epsilon_t</span> are generated according to an ARMA(1, 1) process: <span class="math display">
\begin{aligned}
  \epsilon_t &amp;= \psi \epsilon_{t-1} + \xi_t + \theta \xi_{t-1}, \\
  \xi_t &amp;\sim N(0, \sigma^2).
\end{aligned}
</span> We set <span class="math inline">\psi</span> and <span class="math inline">\theta</span> jointly to each value in <span class="math inline">\{ 0.1, 0.8, 0.9, 0.95, 0.99 \}</span> to simulate time series with increasing temporal dependence. The innovation variance was set to <span class="math inline">\sigma^2 = (1 - \psi^2) / (1 + 2\psi \xi + \xi^2)</span> (to ensure that the process has constant variance). For each setting, 25 simulated datasets were generated.</p>
<p>To provide point predictions for the ACI algorithms, at each time <span class="math inline">t \geq 200</span> a random forest model was fitted to the previously observed data using the <code>ranger</code> <code>R</code> package <span class="citation" data-cites="wright2017ranger">(<a href="#ref-wright2017ranger" role="doc-biblioref">Wright and Ziegler 2017</a>)</span>. The estimated model was then used to predict the subsequent time point. The maximum radius <span class="math inline">D</span> was estimated as the maximum residual observed between time points <span class="math inline">t=200</span> and <span class="math inline">t=249</span>. The ACI models were then executed starting at time point <span class="math inline">t = 250</span>. All metrics are based on time points <span class="math inline">t \geq 300</span> to allow time for the ACI methods to initialize.</p>
<p>The coverage errors, mean interval widths, and path lengths of each of the algorithms for <span class="math inline">\alpha = 0.9</span> are shown in <a href="#fig-simulation-one-results">Figure&nbsp;6</a> (results for <span class="math inline">\alpha \in \{ 0.8, 0.95 \}</span> were similar and are available in the appendix). All methods achieved near optimal empirical coverage, although SAOCP tended to slightly undercover. The mean interval widths were similar across methods, although again SAOCP had slightly shorter intervals (as could be expected given its tendency to undercover). The path length of SAOCP was larger than any of the other methods. To investigate why, <a href="#fig-simulation-one-example">Figure&nbsp;7</a> plots <span class="math inline">w_t - w_{t-1}</span>, the difference in interval width between times <span class="math inline">t-1</span> and <span class="math inline">t</span>, for each method in one of the simulations. The interval widths for AgACI and FACI change slowly relative to those for SF-OGD and SAOCP. For SAOCP, we can see the interval widths have larger fluctuations than for the other methods, explaining its higher path width.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-simulation-one-results" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-simulation-one-results-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;6: Coverage errors, mean interval widths, and path lengths for the first simulation study with target coverage <span class="math inline">\alpha = 0.9</span>.</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-simulation-one-example" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-simulation-one-example-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;7: Difference in successive interval widths (<span class="math inline">w_t - w_{t-1}</span>) from an illustrative simulation from the first simulation study.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="distribution-shift" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="distribution-shift"><span class="header-section-number">4.2</span> Distribution shift</h2>
<p>This simulation study features time series with distribution shifts. The setup is quite simple in order to probe the basic performance of the methods in response to distribution shift. As a baseline, we simulate time series of independent data with <span class="math display">
\begin{aligned}
  y_t &amp;\sim N(0, \sigma_t^2), \\
  \sigma_t &amp;= 0.2,
\end{aligned}
</span> for all <span class="math inline">t \in \llbracket T \rrbracket</span> (<span class="math inline">T = 500</span>). In the second type of time series, the observations are still independent but their variance increases halfway through the time series: <span class="math display">
\begin{aligned}
y_t &amp;\sim N(0, \sigma_t^2), \\
\sigma_t &amp;= 0.2 + 0.5 \mathbb{I}[t &gt; 250].
\end{aligned}
</span> In each case, the ACI algorithms are provided with the unbiased predictions <span class="math inline">\hat{\mu}_t = 0</span>, <span class="math inline">t \in \llbracket T \rrbracket</span>. Fifty simulated datasets were generated for each type of time series.</p>
<p>The coverage error, mean path length, and mean interval widths of the algorithms are summarized in <a href="#fig-simulation-two-joint">Figure&nbsp;8</a> (an alternative plot is included in the appendix as <a href="#fig-simulation-two-results">Figure&nbsp;13</a>). The coverage error of all the algorithms is near the desired value in the absence of distribution shift. On the contrary, all of the algorithms except AgACI and FACI undercover when there is distributional shift. SAOCP tends to have higher average path lengths than the other methods. An illustrative example of prediction intervals generated by each method for one of the simulated time series with distribution shift is shown in <a href="#fig-simulation-two-example">Figure&nbsp;9</a>. The SAOCP prediction intervals in the example before the distribution shift are more jagged than those produced by the other methods, which illustrates why SAOCP may have longer path lengths.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-simulation-two-joint" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-simulation-two-joint-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;8: Mean interval width vs coverage error (top) and Mean Path Length vs.&nbsp;coverage error (bottom) for the second simulation study. The error bars represent the 10% to 90% quantiles of the metrics over the simulation datasets.</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-simulation-two-example" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-simulation-two-example-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;9: Example prediction intervals (target coverage <span class="math inline">\alpha = 0.9</span>) from the second simulation study of time series with distributional shift, in which the shift occurs at time 250. Blue and red points are observations that fell inside and outside the prediction intervals, respectively.</figcaption>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="sec-case-study" class="level1" data-number="5">
<h1 data-number="5"><span class="header-section-number">5</span> Case Study: Influenza Forecasting</h1>
<p>Influenza is a highly infectious disease that is estimated to infect approximately one billion individuals each year around the world <span class="citation" data-cites="krammer2018influenza">(<a href="#ref-krammer2018influenza" role="doc-biblioref">Krammer et al. 2018</a>)</span>. Influenza incidence in temperate climates tends to follow a seasonal pattern, with the highest number of infections during what is commonly referred to as the <span class="citation" data-cites="lofgren2007influenza">(<a href="#ref-lofgren2007influenza" role="doc-biblioref">Lofgren et al. 2007</a>)</span>. Accurate forecasting of influenza is of significant interest to aid in public health planning and resource allocation. To investigate the accuracy of influenza forecasts, the US Centers for Disease Control (CDC) initiated a challenge, referred to as FluSight, in which teams from multiple institutions submitted weekly forecasts of influenza incidence <span class="citation" data-cites="biggerstaff2016flusight">(<a href="#ref-biggerstaff2016flusight" role="doc-biblioref">Biggerstaff et al. 2016</a>)</span>. <span class="citation" data-cites="reich2019influenza">Reich et al. (<a href="#ref-reich2019influenza" role="doc-biblioref">2019</a>)</span> evaluated the accuracy of the forecasts over seven flu seasons from 2010 to 2017. As a case study, we investigate the use of ACI algorithms to augment the FluSight forecasts with prediction intervals.</p>
<p>The FluSight challenge collected forecasts for multiple prediction targets. For this case study, we focus on national (US) one-week ahead forecasts of weighted influenza-like illness (wILI), which is a population-weighted percentage of doctors visits where patients presented with influenza-like symptoms <span class="citation" data-cites="biggerstaff2016flusight">(<a href="#ref-biggerstaff2016flusight" role="doc-biblioref">Biggerstaff et al. 2016</a>)</span>. The FluSight dataset, which is publicy available, include forecasts derived from 21 different forecasting models, from both mechanistic and statistical viewpoints <span class="citation" data-cites="tushar2018flusightnetwork">Tushar et al. (<a href="#ref-tushar2019flusight" role="doc-biblioref">2019</a>)</span>. For our purposes, we treat the way the forecasts were produced as a black box.</p>
<p>Formally, let <span class="math inline">y_{t}</span>, <span class="math inline">t \in \llbracket T \rrbracket</span> be the observed national wILI at time <span class="math inline">t</span>, and let <span class="math inline">\hat{\mu}_{j,t}</span>, <span class="math inline">j \in \llbracket J \rrbracket</span>, be the one-week ahead forecast of the wILI from model <span class="math inline">j</span> at time <span class="math inline">t</span>. Two of the original 21 forecasting methods were excluded from this case study due to poor predictive performance ( and ). In addition, six methods had identical forecasts (, , , , ), and therefore we only included one () in the analysis. The ACI methods were then applied to the log-observations and log-predictions, where the log-transformation was used to constrain the final prediction intervals to be positive. The first flu season (2010-2011) was used as a warm-up for each ACI method, and we report the empirical performance of the prediction intervals for the subsequent seasons (six seasons from 2012-2013 to 2016-2017). The ACI algorithms target prediction intervals with coverage of <span class="math inline">\alpha = 0.8</span>, <span class="math inline">\alpha = 0.9</span>, and <span class="math inline">\alpha = 0.95</span>. As in the simulation study, we used the interval constructor corresponding to the original presentaiton of each algorithm (see <a href="#tbl-aci">Table&nbsp;1</a>).</p>
<p>The coverage errors, mean interval widths, and path lengths of the prediction intervals for each of the underlying forecast models is shown in <a href="#fig-case-study-metrics">Figure&nbsp;10</a>. In all cases the absolute coverage error was less than <span class="math inline">0.1</span>. SF-OGD performed particularly well, with coverage errors close to zero for all forecasting models. Interval widths were similar across methods, with SAOCP slightly shorter. Path Lengths were shorter for AgACI and FACI and longer for SAOCP.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-case-study-metrics" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-case-study-metrics-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;10: Coverage errors, mean interval widths, and path lengths of prediction intervals generated with each ACI method based on forecasts from each of the 19 underlying influenza forecasting models.</figcaption>
</figure>
</div>
</div>
</div>
<p>As an illustrative example, in <a href="#fig-case-study-example">Figure&nbsp;11</a> we plot the point forecasts from one of the forecasting models (based on SARIMA with no seasonal differencing) and the associated ACI-generated 90% prediction intervals for each season from 2011-2017. In general, in this practical setting all of the ACI algorithms yield quite similar prediction intervals. Interestingly, the forecasts in 2011-2012 underpredicted the observations for much of the season. The algorithm responds by making the intervals wider to cover the observations, and because the intervals are symmetric the lower bound then becomes unrealistically low. A similar phenomenon can be seen in the growth phase of the 2012/2013 season as well.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-case-study-example" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-case-study-example-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;11: Example conformal prediction intervals for six flu seasons based on forecasts from a SARIMA type model.</figcaption>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-discussion" class="level1" data-number="6">
<h1 data-number="6"><span class="header-section-number">6</span> Discussion</h1>
<p>The results of our simulations and case study show that, when tuning parameters are chosen well, Adaptive Conformal Inference algorithms yield well-performing prediction intervals. On the contrary, poor choice of tuning parameters can lead to intervals of low utility. Furthermore, in some cases the prediction intervals may appear to perform well with respect to metrics like the empirical coverage error, while simultaneously being useless in practice. The original ACI algorithm illustrates this phenomenon: too small a value of its learning rate <span class="math inline">\gamma</span> yields prediction intervals that are not reactive enough, while too large a value yields intervals that change too fast. In both cases, the empirical coverage may appear well-calibrated, while the prediction intervals will not be useful. Thus, the core challenge in designing an ACI algorithm is in finding an optimal level of reactivity for the prediction intervals. As users of these algorithms, the challenge is in finding values for the tuning parameters that avoid pathological behaviors.</p>
<p>Several of the algorithms investigated in this paper handle the problem of finding an optimal level of reactivity by aggregating prediction intervals generated by a set of underlying ACI algorithms. Our results show the algorithms can perform well in multiple difficult scenarios. However, the overall effect of these approaches is to shift the problem to a higher level of abstraction: we still need to set tuning parameters that control the amount of reactivity, but do so at a higher level than the original ACI algorithm. It is desirable that these tuning parameters be easily interpretable, with simple strategies available for setting them. An advantage of the SF-OGD and SAOCP algorithms in this respect are that their main tuning parameter, the maximum radius <span class="math inline">D</span>, is easily interpretable as the maximum possible difference between the input predictions and the truth. It is also straightforward to choose this parameter based on a calibration set, although this strategy does not necessarily work well in cases of distribution shift. We also found that an advantage of the AgACI method is its robustness to the choice of its main tuning parameter, the set of candidate learning rates. Indeed, if AgACI does not perform well, one can simply increase the number of candidate learning rates.</p>
<p>A key challenge in tuning the algorithms arises in settings of distribution shift, where methods for choosing hyperparameters based on a calibration set from before the distribution shift will likely not perform well. The second simulation study we conducted probed this setting in a simple scenario. We found that several of the methods yielded prediction intervals that had non-optimal empirical coverage. As we picked hyperparameters based on a calibration set formed before the distribution shift, it is not surprising that the resulting tuning parameters are not optimal. This underscores the difficulty in designing ACI algorithms that can adapt to distribution shifts, and in finding robust methods for choosing hyperparameters. In practice, it is possible the second simulation study does not accurately reflect real-world scenarios. Indeed, the benchmarks presented in <span class="citation" data-cites="bhatnagar2023saocp">Bhatnagar et al. (<a href="#ref-bhatnagar2023saocp" role="doc-biblioref">2023</a>)</span> using the datasets from the M4 competition <span class="citation" data-cites="makridakis2020m4">(<a href="#ref-makridakis2020m4" role="doc-biblioref">Makridakis, Spiliotis, and Assimakopoulos 2020</a>)</span>, and using point predictions generated by diverse prediction algorithms, found that ACI algorithms exhibited good performance in terms of empirical coverage. Nevertheless, our recommendation for future papers in this line of research is to include simulation studies for simple distributional shift scenarios as a benchmark.</p>
<p>Our case study results illustrate the dependence of the ACI algorithms on having access to high-quality point predictions. If the predictions are biased, for example, then the prediction intervals may be able to achieve optimal coverage at the expense of larger interval widths. Using ensemble methods to combine forecasts from several flexible machine learning models is one strategy that can be used to hedge against model misspecification and improve the quality of forecasts <span class="citation" data-cites="makridakis2020m4">(<a href="#ref-makridakis2020m4" role="doc-biblioref">Makridakis, Spiliotis, and Assimakopoulos 2020</a>)</span>.</p>
<p>There remain many possible extensions of ACI algorithms. The algorithms presented in this work primarily consider symmetric intervals evaluated using the pinball loss function (AgACI can yield asymmetric intervals because the aggregation rule is applied separately to the lower and upper bounds from the underlying experts, but those underlying experts only produce symmetric intervals). A simple extension would switch to using the interval loss function <span class="citation" data-cites="gneiting2007scoring">(<a href="#ref-gneiting2007scoring" role="doc-biblioref">Gneiting and Raftery 2007</a>)</span>, which would allow for asymmetric intervals where two parameters are learned for the upper and lower bounds, respectively. It may also be of interest to generate prediction intervals that have coverage guarantees for arbitrary subsets of observations (for example, we may seek prediction intervals for daily observations that have near optimal coverage for every day of the week, or month of the year), similar to guarantees provided by the MultiValid Prediction method described in <span class="citation" data-cites="bastani2022practical">(<a href="#ref-bastani2022practical" role="doc-biblioref">Bastani et al. 2022</a>)</span>. Another avenue for theoretical research is to propose algorithms with provable bounds for the coverage and regret that do not depend on the outcome being bounded.</p>
<section id="acknowledgements" class="level2 unnumbered">
<h2 class="unnumbered anchored" data-anchor-id="acknowledgements">Acknowledgements</h2>
<p>This research is partially supported by the Agence Nationale de la Recherche as part of the “Investissements d’avenir” program (reference ANR-19-P3IA-0001; PRAIRIE 3IA Institute). We would like to thank Margaux Zaffran for providing helpful comments on the manuscript.</p>
</section>
</section>
<section id="references" class="level1 unnumbered">
<h1 class="unnumbered">References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" role="list">
<div id="ref-angelopoulos2022gentle" class="csl-entry" role="listitem">
Angelopoulos, Anastasios N., and Stephen Bates. 2022. <span>“A Gentle Introduction to Conformal Prediction and Distribution-Free Uncertainty Quantification.”</span> <a href="https://arxiv.org/abs/2107.07511">https://arxiv.org/abs/2107.07511</a>.
</div>
<div id="ref-bastani2022practical" class="csl-entry" role="listitem">
Bastani, Osbert, Varun Gupta, Christopher Jung, Georgy Noarov, Ramya Ramalingam, and Aaron Roth. 2022. <span>“Practical Adversarial Multivalid Conformal Prediction.”</span> <a href="https://arxiv.org/abs/2206.01067">https://arxiv.org/abs/2206.01067</a>.
</div>
<div id="ref-bhatnagar2023saocp" class="csl-entry" role="listitem">
Bhatnagar, Aadyot, Huan Wang, Caiming Xiong, and Yu Bai. 2023. <span>“Improved Online Conformal Prediction via Strongly Adaptive Online Learning.”</span> <a href="https://arxiv.org/abs/2302.07869">https://arxiv.org/abs/2302.07869</a>.
</div>
<div id="ref-biggerstaff2016flusight" class="csl-entry" role="listitem">
Biggerstaff, Matthew, David Alper, Mark Dredze, Spencer Fox, Isaac Chun-Hai Fung, Kyle S. Hickmann, Bryan Lewis, et al. 2016. <span>“Results from the Centers for Disease Control and Prevention’s Predict the 2013–2014 Influenza Season Challenge.”</span> <em>BMC Infectious Diseases</em> 16 (1): 357. <a href="https://doi.org/10.1186/s12879-016-1669-x">https://doi.org/10.1186/s12879-016-1669-x</a>.
</div>
<div id="ref-cesabianchi2006games" class="csl-entry" role="listitem">
Cesa-Bianchi, Nicolo, and Gabor Lugosi. 2006. <em>Prediction, Learning, and Games</em>. Cambridge University Press. <a href="https://doi.org/10.1017/CBO9780511546921">https://doi.org/10.1017/CBO9780511546921</a>.
</div>
<div id="ref-diquigiovanni2022fd" class="csl-entry" role="listitem">
Diquigiovanni, Jacopo, Matteo Fontana, Aldo Solari, Simone Vantini, and Paolo Vergottini. 2022. <em>conformalInference.fd: Tools for Conformal Inference for Regression in Multivariate Functional Setting</em>. <a href="https://CRAN.R-project.org/package=conformalInference.fd">https://CRAN.R-project.org/package=conformalInference.fd</a>.
</div>
<div id="ref-feldman2023achieving" class="csl-entry" role="listitem">
Feldman, Shai, Liran Ringel, Stephen Bates, and Yaniv Romano. 2023. <span>“Achieving Risk Control in Online Learning Settings.”</span> <a href="https://arxiv.org/abs/2205.09095">https://arxiv.org/abs/2205.09095</a>.
</div>
<div id="ref-friedman1983" class="csl-entry" role="listitem">
Friedman, Jerome H., Eric Grosse, and Werner Stuetzle. 1983. <span>“Multidimensional Additive Spline Approximation.”</span> <em>SIAM Journal on Scientific and Statistical Computing</em> 4 (2): 291–301. <a href="https://doi.org/10.1137/0904023">https://doi.org/10.1137/0904023</a>.
</div>
<div id="ref-opera2023" class="csl-entry" role="listitem">
Gaillard, Pierre, Yannig Goude, Laurent Plagne, Thibaut Dubois, and Benoit Thieurmel. 2023. <em>Opera: Online Prediction by Expert Aggregation</em>. <a href="http://pierre.gaillard.me/opera.html">http://pierre.gaillard.me/opera.html</a>.
</div>
<div id="ref-gibbs2021adaptive" class="csl-entry" role="listitem">
Gibbs, Isaac, and Emmanuel Candès. 2021. <span>“Adaptive Conformal Inference Under Distribution Shift.”</span> <a href="https://arxiv.org/abs/2106.00170">https://arxiv.org/abs/2106.00170</a>.
</div>
<div id="ref-gibbs2022faci" class="csl-entry" role="listitem">
———. 2022. <span>“Conformal Inference for Online Prediction with Arbitrary Distribution Shifts.”</span> <a href="https://arxiv.org/abs/2208.08401">https://arxiv.org/abs/2208.08401</a>.
</div>
<div id="ref-gneiting2007scoring" class="csl-entry" role="listitem">
Gneiting, Tilmann, and Adrian E Raftery. 2007. <span>“Strictly Proper Scoring Rules, Prediction, and Estimation.”</span> <em>Journal of the American Statistical Association</em> 102 (477): 359–78. <a href="https://doi.org/10.1198/016214506000001437">https://doi.org/10.1198/016214506000001437</a>.
</div>
<div id="ref-gradu2022adaptive" class="csl-entry" role="listitem">
Gradu, Paula, Elad Hazan, and Edgar Minasyan. 2022. <span>“Adaptive Regret for Control of Time-Varying Dynamics.”</span> <a href="https://arxiv.org/abs/2007.04393">https://arxiv.org/abs/2007.04393</a>.
</div>
<div id="ref-krammer2018influenza" class="csl-entry" role="listitem">
Krammer, Florian, Gavin J. D. Smith, Ron A. M. Fouchier, Malik Peiris, Katherine Kedzierska, Peter C. Doherty, Peter Palese, et al. 2018. <span>“Influenza.”</span> <em>Nature Reviews Disease Primers</em> 4 (1): 3. <a href="https://doi.org/10.1038/s41572-018-0002-y">https://doi.org/10.1038/s41572-018-0002-y</a>.
</div>
<div id="ref-lei2020cfcausal" class="csl-entry" role="listitem">
Lei, Lihua, and Emmanuel Candès. 2020. <span>“Conformal Inference of Counterfactuals and Individual Treatment Effects.”</span> <em>Arxiv</em>. <a href="https://arxiv.org/abs/2006.06138">https://arxiv.org/abs/2006.06138</a>.
</div>
<div id="ref-lofgren2007influenza" class="csl-entry" role="listitem">
Lofgren, Eric, N. H. Fefferman, Y. N. Naumov, J. Gorski, and E. N. Naumova. 2007. <span>“Influenza Seasonality: Underlying Causes and Modeling Theories.”</span> <em>Journal of Virology</em> 81 (11): 5429–36. <a href="https://doi.org/10.1128/jvi.01680-06">https://doi.org/10.1128/jvi.01680-06</a>.
</div>
<div id="ref-makridakis2020m4" class="csl-entry" role="listitem">
Makridakis, Spyros, Evangelos Spiliotis, and Vassilios Assimakopoulos. 2020. <span>“The M4 Competition: 100,000 Time Series and 61 Forecasting Methods.”</span> <em>International Journal of Forecasting</em> 36 (1): 54–74. https://doi.org/<a href="https://doi.org/10.1016/j.ijforecast.2019.04.014">https://doi.org/10.1016/j.ijforecast.2019.04.014</a>.
</div>
<div id="ref-orabona2018sfogd" class="csl-entry" role="listitem">
Orabona, Francesco, and Dávid Pál. 2018. <span>“Scale-Free Online Learning.”</span> <em>Theoretical Computer Science</em> 716: 50–69. https://doi.org/<a href="https://doi.org/10.1016/j.tcs.2017.11.021">https://doi.org/10.1016/j.tcs.2017.11.021</a>.
</div>
<div id="ref-reich2019influenza" class="csl-entry" role="listitem">
Reich, Nicholas G, Logan C Brooks, Spencer J Fox, Sasikiran Kandula, Craig J McGowan, Evan Moore, Dave Osthus, et al. 2019. <span>“A Collaborative Multiyear, Multimodel Assessment of Seasonal Influenza Forecasting in the United States.”</span> <em>Proc. Natl. Acad. Sci. U. S. A.</em> 116 (8): 3146–54.
</div>
<div id="ref-shafer2008conformal" class="csl-entry" role="listitem">
Shafer, Glenn, and Vladimir Vovk. 2008. <span>“A Tutorial on Conformal Prediction.”</span> <em>J. Mach. Learn. Res.</em> 9 (June): 371–421.
</div>
<div id="ref-tibshirani2019ci" class="csl-entry" role="listitem">
Tibshirani, Ryan, Jacopo Diquigiovanni, Matteo Fontana, and Paolo Vergottini. 2019. <em>conformalInference: Tools for Conformal Inference in Regression</em>.
</div>
<div id="ref-tushar2019flusight" class="csl-entry" role="listitem">
Tushar, Abhinav, Nicholas G Reich, tkcy, brookslogan, d-osthus, Craig McGowan, Evan Ray, et al. 2019. <span>“<span class="nocase">FluSightNetwork/cdc-flusight-ensemble: End of 2018/2019 US influenza season</span>.”</span> Zenodo. <a href="https://doi.org/10.5281/zenodo.3454212">https://doi.org/10.5281/zenodo.3454212</a>.
</div>
<div id="ref-tushar2018flusightnetwork" class="csl-entry" role="listitem">
Tushar, Abhinav, Nicholas Reich, Teresa Yamana, Dave Osthus, Craig McGowan, Evan Ray, and et al. 2018. <span>“FluSightNetwork: Cdc-Flusight-Ensemble Repository.”</span> <a href="https://github.com/FluSightNetwork/cdc-flusight-ensemble" class="uri">https://github.com/FluSightNetwork/cdc-flusight-ensemble</a>.
</div>
<div id="ref-vovk2005" class="csl-entry" role="listitem">
Vovk, Vladimir, Alex Gammerman, and Glenn Shafer. 2005. <em>Algorithmic Learning in a Random World</em>. Berlin, Heidelberg: Springer-Verlag.
</div>
<div id="ref-wintenberger2017boa" class="csl-entry" role="listitem">
Wintenberger, Olivier. 2017. <span>“Optimal Learning with Bernstein Online Aggregation.”</span> <em>Machine Learning</em> 106 (1): 119–41. <a href="https://doi.org/10.1007/s10994-016-5592-6">https://doi.org/10.1007/s10994-016-5592-6</a>.
</div>
<div id="ref-wright2017ranger" class="csl-entry" role="listitem">
Wright, Marvin N., and Andreas Ziegler. 2017. <span>“<span class="nocase">ranger</span>: A Fast Implementation of Random Forests for High Dimensional Data in <span>C++</span> and <span>R</span>.”</span> <em>Journal of Statistical Software</em> 77 (1): 1–17. <a href="https://doi.org/10.18637/jss.v077.i01">https://doi.org/10.18637/jss.v077.i01</a>.
</div>
<div id="ref-xu2021enbpi" class="csl-entry" role="listitem">
Xu, Chen, and Yao Xie. 2021. <span>“Conformal Prediction Interval for Dynamic Time-Series.”</span> In <em>Proceedings of the 38th International Conference on Machine Learning</em>, edited by Marina Meila and Tong Zhang, 139:11559–69. Proceedings of Machine Learning Research. PMLR. <a href="https://proceedings.mlr.press/v139/xu21h.html">https://proceedings.mlr.press/v139/xu21h.html</a>.
</div>
<div id="ref-xu2023spci" class="csl-entry" role="listitem">
———. 2023. <span>“Sequential Predictive Conformal Inference for Time Series.”</span> In <em>Proceedings of the 40th International Conference on Machine Learning</em>, edited by Andreas Krause, Emma Brunskill, Kyunghyun Cho, Barbara Engelhardt, Sivan Sabato, and Jonathan Scarlett, 202:38707–27. Proceedings of Machine Learning Research. PMLR. <a href="https://proceedings.mlr.press/v202/xu23r.html">https://proceedings.mlr.press/v202/xu23r.html</a>.
</div>
<div id="ref-zaffran2022agaci" class="csl-entry" role="listitem">
Zaffran, Margaux, Olivier Feron, Yannig Goude, Julie Josse, and Aymeric Dieuleveut. 2022. <span>“Adaptive Conformal Predictions for Time Series.”</span> In <em>Proceedings of the 39th International Conference on Machine Learning</em>, edited by Kamalika Chaudhuri, Stefanie Jegelka, Le Song, Csaba Szepesvari, Gang Niu, and Sivan Sabato, 162:25834–66. Proceedings of Machine Learning Research. PMLR. <a href="https://proceedings.mlr.press/v162/zaffran22a.html">https://proceedings.mlr.press/v162/zaffran22a.html</a>.
</div>
</div>
</section>
<section id="appendix" class="level1" data-number="7">
<h1 data-number="7"><span class="header-section-number">7</span> Appendix</h1>
<section id="additional-simulation-study-results" class="level2" data-number="7.1">
<h2 data-number="7.1" class="anchored" data-anchor-id="additional-simulation-study-results"><span class="header-section-number">7.1</span> Additional simulation study results</h2>
<div class="cell">
<div class="cell-output-display">
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="paper_files/figure-html/simulation_one_plot_appendix-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Coverage errors, mean interval widths, and path lengths for the first simulation study with target coverage <span class="math inline">\alpha \in \{ 0.8, 0.9, 0.95 \}</span>.</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-simulation-one-joint" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-simulation-one-joint-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;12: Mean Interval Width vs Coverage Error for the first simulation study. The error bars represent the 10% to 90% quantiles of the metrics over the simulation datasets.</figcaption>
</figure>
</div>
</div>
</div>
<div class="cell">
<div class="cell-output-display">
<div id="fig-simulation-two-results" class="quarto-figure quarto-figure-center anchored">
<figure class="figure">
<p><img src="paper_files/figure-html/fig-simulation-two-results-1.svg" class="img-fluid figure-img"></p>
<figcaption class="figure-caption">Figure&nbsp;13: Coverage error, mean interval width, and path length for <span class="math inline">\alpha = 0.8, 0.9, 0.95</span> and simulations with and without distributional shift.</figcaption>
</figure>
</div>
</div>
</div>
<!-- -->

</section>
</section>

<div id="quarto-appendix" class="default"><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Reuse</h2><div id="quarto-reuse" class="quarto-appendix-contents"><div><a rel="license" href="https://creativecommons.org/licenses/by/4.0/">https://creativecommons.org/licenses/by/4.0/</a></div></div></section><section class="quarto-appendix-contents"><h2 class="anchored quarto-appendix-heading">Citation</h2><div><div class="quarto-appendix-secondary-label">BibTeX citation:</div><pre class="sourceCode code-with-copy quarto-appendix-bibtex"><code class="sourceCode bibtex">@article{susmann2023,
  author = {Susmann, Herbert and Chambaz, Antoine and Josse, Julie},
  publisher = {Société Française de Statistique},
  title = {AdaptiveConformal: {An} {`R`} {Package} for {Adaptive}
    {Conformal} {Inference}},
  journal = {Computo},
  date = {2023-10-09},
  url = {https://computo.sfds.asso.fr/template-computo-quarto},
  doi = {xxxx},
  issn = {2824-7795},
  langid = {en},
  abstract = {Conformal Inference (CI) is a popular approach for
    generating finite sample prediction intervals based on the output of
    any point prediction method when data are exchangeable. Adaptive
    Conformal Inference (ACI) algorithms extend CI to the case of
    sequentially observed data, such as time series, and exhibit strong
    theoretical guarantees without having to assume exchangeability of
    the observed data. The common thread that unites algorithms in the
    ACI family is that they adaptively adjust the width of the generated
    prediction intervals in response to the observed data. We provide a
    detailed description of five ACI algorithms and their theoretical
    guarantees, and test their performance in simulation studies. We
    then present a case study of producing prediction intervals for
    influenza incidence in the United States based on black-box point
    forecasts. Implementations of all the algorithms are released as an
    open-source `R` package, `AdaptiveConformal`, which also includes
    tools for visualizing and summarizing conformal prediction
    intervals.}
}
</code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre><div class="quarto-appendix-secondary-label">For attribution, please cite this work as:</div><div id="ref-susmann2023" class="csl-entry quarto-appendix-citeas" role="listitem">
Susmann, Herbert, Antoine Chambaz, and Julie Josse. 2023.
<span>“AdaptiveConformal: An `R` Package for Adaptive Conformal
Inference.”</span> <em>Computo</em>, October. <a href="https://doi.org/xxxx">https://doi.org/xxxx</a>.
</div></div></section></div></main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  const viewSource = window.document.getElementById('quarto-view-source') ||
                     window.document.getElementById('quarto-code-tools-source');
  if (viewSource) {
    const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
    viewSource.addEventListener("click", function(e) {
      if (sourceUrl) {
        // rstudio viewer pane
        if (/\bcapabilities=\b/.test(window.location)) {
          window.open(sourceUrl);
        } else {
          window.location.href = sourceUrl;
        }
      } else {
        const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
        modal.show();
      }
      return false;
    });
  }
  function toggleCodeHandler(show) {
    return function(e) {
      const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
      for (let i=0; i<detailsSrc.length; i++) {
        const details = detailsSrc[i].parentElement;
        if (show) {
          details.open = true;
        } else {
          details.removeAttribute("open");
        }
      }
      const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
      const fromCls = show ? "hidden" : "unhidden";
      const toCls = show ? "unhidden" : "hidden";
      for (let i=0; i<cellCodeDivs.length; i++) {
        const codeDiv = cellCodeDivs[i];
        if (codeDiv.classList.contains(fromCls)) {
          codeDiv.classList.remove(fromCls);
          codeDiv.classList.add(toCls);
        } 
      }
      return false;
    }
  }
  const hideAllCode = window.document.getElementById("quarto-hide-all-code");
  if (hideAllCode) {
    hideAllCode.addEventListener("click", toggleCodeHandler(false));
  }
  const showAllCode = window.document.getElementById("quarto-show-all-code");
  if (showAllCode) {
    showAllCode.addEventListener("click", toggleCodeHandler(true));
  }
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
          // target, if specified
          link.setAttribute("target", "_blank");
      }
    }
});
</script><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb1" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> "AdaptiveConformal: An `R` Package for Adaptive Conformal Inference"</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="an">subtitle:</span><span class="co"> "AdaptiveConformal: An `R` Package for Adaptive Conformal Inference"</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="an">author:</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Herbert Susmann</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">    corresponding: true</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">    email: herbert.susmann@dauphine.psl.eu</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://herbsusmann.com</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-3540-8255</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: CEREMADE (UMR 7534), Université Paris Dauphine - PSL, Place du Maréchal de Lattre de Tassigny, Paris, 75016, France</span></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://www.ceremade.dauphine.fr/</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Antoine Chambaz</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co">    email: antoine.chambaz@u-paris.fr</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a><span class="co">    url: https://helios2.mi.parisdescartes.fr/~chambaz/</span></span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0002-5592-6471</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: MAP5 (UMR 8145), Université Paris Cité</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co">        department: </span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://map5.mi.parisdescartes.fr/</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a><span class="co">  - name: Julie Josse</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a><span class="co">    email: julie.josse@inria.fr</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a><span class="co">    url: http://juliejosse.com/</span></span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="co">    orcid: 0000-0001-9547-891X</span></span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a><span class="co">    affiliations:</span></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="co">      - name: Inria PreMeDICaL team, Université de Montpellier</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a><span class="co">        url: https://team.inria.fr/premedical/</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a><span class="an">date:</span><span class="co"> last-modified</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a><span class="an">date-modified:</span><span class="co"> last-modified</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a><span class="an">description:</span><span class="co"> |</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a><span class="co">  Conformal Inference (CI) is a popular approach for generating finite sample prediction intervals based on the output of any point prediction method when data are exchangeable. Adaptive Conformal Inference (ACI) algorithms extend CI to the case of sequentially observed data, such as time series, and exhibit strong theoretical guarantees without having to assume exchangeability of the observed data. The common thread that unites algorithms in the ACI family is that they adaptively adjust the width of the generated prediction intervals in response to the observed data. We provide a detailed description of five ACI algorithms and their theoretical guarantees, and test their performance in simulation studies. We then present a case study of producing prediction intervals for influenza incidence in the United States based on black-box point forecasts. Implementations of all the algorithms are released as an open-source `R` package, `AdaptiveConformal`, which also includes tools for visualizing and summarizing conformal prediction intervals.</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a><span class="an">abstract:</span><span class="co"> &gt;+</span></span>
<span id="cb1-33"><a href="#cb1-33" aria-hidden="true" tabindex="-1"></a><span class="co">  Conformal Inference (CI) is a popular approach for generating finite sample prediction intervals based on the output of any point prediction method when data are exchangeable. Adaptive Conformal Inference (ACI) algorithms extend CI to the case of sequentially observed data, such as time series, and exhibit strong theoretical guarantees without having to assume exchangeability of the observed data. The common thread that unites algorithms in the ACI family is that they adaptively adjust the width of the generated prediction intervals in response to the observed data. We provide a detailed description of five ACI algorithms and their theoretical guarantees, and test their performance in simulation studies. We then present a case study of producing prediction intervals for influenza incidence in the United States based on black-box point forecasts. Implementations of all the algorithms are released as an open-source `R` package, `AdaptiveConformal`, which also includes tools for visualizing and summarizing conformal prediction intervals.</span></span>
<span id="cb1-34"><a href="#cb1-34" aria-hidden="true" tabindex="-1"></a><span class="an">keywords:</span><span class="co"> [Conformal inference, Adaptive conformal inference, time series, R]</span></span>
<span id="cb1-35"><a href="#cb1-35" aria-hidden="true" tabindex="-1"></a><span class="an">citation:</span></span>
<span id="cb1-36"><a href="#cb1-36" aria-hidden="true" tabindex="-1"></a><span class="co">  type: article-journal</span></span>
<span id="cb1-37"><a href="#cb1-37" aria-hidden="true" tabindex="-1"></a><span class="co">  container-title: "Computo"</span></span>
<span id="cb1-38"><a href="#cb1-38" aria-hidden="true" tabindex="-1"></a><span class="co">  doi: "xxxx"</span></span>
<span id="cb1-39"><a href="#cb1-39" aria-hidden="true" tabindex="-1"></a><span class="co">  url: https://computo.sfds.asso.fr/template-computo-quarto</span></span>
<span id="cb1-40"><a href="#cb1-40" aria-hidden="true" tabindex="-1"></a><span class="co">  publisher: "Société Française de Statistique"</span></span>
<span id="cb1-41"><a href="#cb1-41" aria-hidden="true" tabindex="-1"></a><span class="co">  issn: "2824-7795"</span></span>
<span id="cb1-42"><a href="#cb1-42" aria-hidden="true" tabindex="-1"></a><span class="an">bibliography:</span><span class="co"> references.bib</span></span>
<span id="cb1-43"><a href="#cb1-43" aria-hidden="true" tabindex="-1"></a><span class="an">github-user:</span><span class="co"> computorg</span></span>
<span id="cb1-44"><a href="#cb1-44" aria-hidden="true" tabindex="-1"></a><span class="an">repo:</span><span class="co"> "template-computo-r"</span></span>
<span id="cb1-45"><a href="#cb1-45" aria-hidden="true" tabindex="-1"></a><span class="an">draft:</span><span class="co"> true # set to false once the build is running</span></span>
<span id="cb1-46"><a href="#cb1-46" aria-hidden="true" tabindex="-1"></a><span class="an">published:</span><span class="co"> false # will be set to true once accepted</span></span>
<span id="cb1-47"><a href="#cb1-47" aria-hidden="true" tabindex="-1"></a><span class="an">format:</span></span>
<span id="cb1-48"><a href="#cb1-48" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-html: </span></span>
<span id="cb1-49"><a href="#cb1-49" aria-hidden="true" tabindex="-1"></a><span class="co">    code-fold: true</span></span>
<span id="cb1-50"><a href="#cb1-50" aria-hidden="true" tabindex="-1"></a><span class="co">  computo-pdf: </span></span>
<span id="cb1-51"><a href="#cb1-51" aria-hidden="true" tabindex="-1"></a><span class="co">    include-in-header:</span></span>
<span id="cb1-52"><a href="#cb1-52" aria-hidden="true" tabindex="-1"></a><span class="co">      - text: |</span></span>
<span id="cb1-53"><a href="#cb1-53" aria-hidden="true" tabindex="-1"></a><span class="co">          \usepackage{stmaryrd}</span></span>
<span id="cb1-54"><a href="#cb1-54" aria-hidden="true" tabindex="-1"></a><span class="co">          \usepackage{xfrac}</span></span>
<span id="cb1-55"><a href="#cb1-55" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb1-56"><a href="#cb1-56" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-57"><a href="#cb1-57" aria-hidden="true" tabindex="-1"></a><span class="fu"># Introduction</span></span>
<span id="cb1-58"><a href="#cb1-58" aria-hidden="true" tabindex="-1"></a>Conformal Inference (CI) is a family of methods for generating finite sample prediction intervals around point predictions when data are exchangeable <span class="co">[</span><span class="ot">@vovk2005; @shafer2008conformal; @angelopoulos2022gentle</span><span class="co">]</span>. The input point predictions can be derived from any prediction method, making CI a powerful tool for augmenting black-box prediction algorithms with prediction intervals. Classical CI methods are able to yield marginally valid intervals with only the assumption that the joint distribution of the data does not change based on the order of the observations (that is, they are exchangeable). However, in many real-world settings data are not exchangeable: for example, time series data usually cannot be assumed to be exchangeable due to temporal dependence. A recent line of research examines the problem of generating prediction intervals for observations that are observed online (that is, one at a time) and for which exchangeability is not assumed to hold <span class="co">[</span><span class="ot">@gibbs2021adaptive; @zaffran2022agaci; @gibbs2022faci; @bhatnagar2023saocp</span><span class="co">]</span>. The methods from this literature, which we refer to generally as _Adaptive Conformal Inference_ (ACI) algorithms, work by adaptively adjusting the width of the generated prediction intervals in response to the observed data. </span>
<span id="cb1-59"><a href="#cb1-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-60"><a href="#cb1-60" aria-hidden="true" tabindex="-1"></a>Informally, suppose a sequence of outcomes $y_t \in \mathbb{R}$, $t = 1, \dots, T$ are observed one at a time. Before seeing each observation, we have at our disposal a point prediction $\hat{\mu}_t \in \mathbb{R}$ that can be generated by any method. Our goal is to find an algorithm for producing prediction intervals $[\ell_t, u_t]$, $\ell_t \leq u_t$ such that, in the long run, the observations $y_t$ fall within the corresponding prediction intervals roughly $\alpha \times 100\%$ of the time: that is, $\lim_{T \to \infty} \sfrac{1}{T} \sum_{t=1}^T \mathbb{I}<span class="sc">\{</span> y_t \in <span class="co">[</span><span class="ot">\ell_t, u_t</span><span class="co">]</span> <span class="sc">\}</span> = \alpha$. The original ACI algorithm <span class="co">[</span><span class="ot">@gibbs2021adaptive</span><span class="co">]</span> is based on a simple idea: if the previous prediction interval at time $(t-1)$ did not cover the true observation, then the next prediction interval at time $t$ is made slightly wider. Conversely, if the previous prediction interval did include the observation, then the next prediction interval is made slightly narrower. It can be shown that this procedure yields prediction intervals that in the long run cover the true observations the desired proportion of the time. </span>
<span id="cb1-61"><a href="#cb1-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-62"><a href="#cb1-62" aria-hidden="true" tabindex="-1"></a>The main tuning parameter of the original ACI algorithm is a learning rate that controls how fast prediction interval width changes. If the learning rate is too low, then the prediction intervals will not be able to adapt fast enough to shifts in the data generating distribution; if it is too large, then the intervals will oscillate widely. The critical dependence of the original ACI algorithm on proper choice of its learning rate spurred subsequent research into meta-algorithms that learn the correct learning rate (or an analogue thereof) in various ways, typically drawing on approaches from the online learning literature. In this paper, we present four such algorithms: Aggregated ACI <span class="co">[</span><span class="ot">AgACI, @zaffran2022agaci</span><span class="co">]</span>, Fully Adaptive Conformal Inference <span class="co">[</span><span class="ot">FACI, @gibbs2022faci</span><span class="co">]</span>, Scale-Free Online Gradient Descent <span class="co">[</span><span class="ot">SF-OGD, @bhatnagar2023saocp</span><span class="co">]</span>, and Strongly Adaptive Online Conformal Prediction <span class="co">[</span><span class="ot">SAOCP, @bhatnagar2023saocp</span><span class="co">]</span>. We note that the adaption of conformal inference techniques is an active area of research and the algorithms we focus on in this work are not exhaustive; see among others @feldman2023achieving, @bastani2022practical, @xu2021enbpi, and @xu2023spci.</span>
<span id="cb1-63"><a href="#cb1-63" aria-hidden="true" tabindex="-1"></a> </span>
<span id="cb1-64"><a href="#cb1-64" aria-hidden="true" tabindex="-1"></a>Our primary practical contribution is an implementation of each algorithm in an open source <span class="in">`R`</span> package, <span class="in">`AdaptiveConformal`</span>, which is available at <span class="co">[</span><span class="ot">https://github.com/herbps10/AdaptiveConformal</span><span class="co">](https://github.com/herbps10/AdaptiveConformal)</span>. The package also includes routines for visualization and summary of the prediction intervals. We note that Python versions of several algorithms were also made available by @zaffran2022agaci and @bhatnagar2023saocp, but to our knowledge this is the first package implementing them in <span class="in">`R`</span>. In addition, several <span class="in">`R`</span> packages exist for conformal inference in other contexts, including <span class="in">`conformalInference`</span> focusing on regression <span class="co">[</span><span class="ot">@tibshirani2019ci</span><span class="co">]</span>, <span class="in">`conformalInference.fd`</span>, with methods for functional responses <span class="co">[</span><span class="ot">@diquigiovanni2022fd</span><span class="co">]</span>, and <span class="in">`cfcausal`</span> for causal inference related functionals <span class="co">[</span><span class="ot">@lei2020cfcausal</span><span class="co">]</span>. Our second practical contribution is to compare the performance of the algorithms in simulation studies and in a case study generating prediction intervals for influenza incidence in the United States based on black-box point forecasts.</span>
<span id="cb1-65"><a href="#cb1-65" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-66"><a href="#cb1-66" aria-hidden="true" tabindex="-1"></a>The rest of the paper unfolds as follows. In @sec-theory, we present a unified theoretical framework for analyzing the ACI algorithms based on the online learning paradigm. In @sec-algorithms we provide descriptions of each algorithm along with their known theoretical properties. In @sec-simulations we compare the performance of the algorithms in several simulation studies. @sec-case-study gives a case study based on forecasting influenza in the United States. Finally, @sec-discussion provides a discussion and ideas for future research in this rapidly expanding field.</span>
<span id="cb1-67"><a href="#cb1-67" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-68"><a href="#cb1-68" aria-hidden="true" tabindex="-1"></a><span class="in">```{r, warning=FALSE, message=FALSE, echo=FALSE}</span></span>
<span id="cb1-69"><a href="#cb1-69" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb1-70"><a href="#cb1-70" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(patchwork)</span>
<span id="cb1-71"><a href="#cb1-71" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(future)</span>
<span id="cb1-72"><a href="#cb1-72" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(furrr)</span>
<span id="cb1-73"><a href="#cb1-73" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(progressr)</span>
<span id="cb1-74"><a href="#cb1-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-75"><a href="#cb1-75" aria-hidden="true" tabindex="-1"></a>knitr<span class="sc">::</span>opts_chunk<span class="sc">$</span><span class="fu">set</span>(<span class="at">echo =</span> <span class="cn">FALSE</span>)</span>
<span id="cb1-76"><a href="#cb1-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-77"><a href="#cb1-77" aria-hidden="true" tabindex="-1"></a><span class="fu">source</span>(<span class="st">"helpers.R"</span>)</span>
<span id="cb1-78"><a href="#cb1-78" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-79"><a href="#cb1-79" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-80"><a href="#cb1-80" aria-hidden="true" tabindex="-1"></a><span class="fu"># Theoretical Framework {#sec-theory}</span></span>
<span id="cb1-81"><a href="#cb1-81" aria-hidden="true" tabindex="-1"></a>*Notation*: for any integer $N \geq 1$ let $\llbracket N \rrbracket := <span class="sc">\{</span> 1, \dots, N <span class="sc">\}</span>$. Let $\mathbb{I}$ be the indicator function. Let $\nabla f$ denote the gradient (subgradient) of the differentiable (convex) function $f$.</span>
<span id="cb1-82"><a href="#cb1-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-83"><a href="#cb1-83" aria-hidden="true" tabindex="-1"></a>We consider an online learning scenario in which we gain access to a sequence of observations $(y_t)_{t \geq 1}$ one at a time (see @cesabianchi2006games for an comprehensive account of online learning theory). Fix $\alpha \in (0, 1)$ to be the target empirical coverage of the prediction intervals. The goal is to output at time $t$ a prediction interval for the unseen observation $y_{t}$, with the prediction interval generated by an _interval construction function_ $\widehat{C}_{t}$. Formally, let $\widehat{C}_t$ be a function that takes as input a parameter $\theta_t \in \mathbb{R}$ and outputs a closed prediction interval $[\ell_t, u_t]$. The interval construction function must be nested: if $\theta^\prime &gt; \theta$, then $\widehat{C}_t(\theta) \subseteq \widehat{C}_t(\theta^\prime)$. In words, larger values of $\theta$ imply wider prediction intervals. The interval constructor is indexed by $t$ to emphasize that it may use other information at each time point, such as a point prediction $\hat{\mu}_t \in \mathbb{R}$. We make no restrictions on how this external information is generated. </span>
<span id="cb1-84"><a href="#cb1-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-85"><a href="#cb1-85" aria-hidden="true" tabindex="-1"></a>Define $r_t := \inf<span class="sc">\{</span>\theta \in \mathbb{R} : \mathbb{I}(y_t \in \widehat{C}_t(\theta)) \}$ to be the _radius_ at time $t$. The radius is the smallest possible $\theta$ such that the prediction interval covers the observation $y_t$. A key assumption for the theoretical analysis of several of the algorithms is that the radii are bounded:</span>
<span id="cb1-86"><a href="#cb1-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-87"><a href="#cb1-87" aria-hidden="true" tabindex="-1"></a>**Assumption**: there exists a $D &gt; 0$ such that $r_t &lt; D$ for all $t$.</span>
<span id="cb1-88"><a href="#cb1-88" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-89"><a href="#cb1-89" aria-hidden="true" tabindex="-1"></a>Next, we describe two existing definitions of interval construction functions.</span>
<span id="cb1-90"><a href="#cb1-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-91"><a href="#cb1-91" aria-hidden="true" tabindex="-1"></a><span class="fu">## Linear Intervals</span></span>
<span id="cb1-92"><a href="#cb1-92" aria-hidden="true" tabindex="-1"></a>A simple method for forming the prediction intervals is to use the parameter $\theta_t$ to directly define the width of the interval. Suppose that at each time $t$ we have access to a point prediction $\hat{\mu}_t \in \mathbb{R}$. Then we can form a symmetric prediction interval around the point estimate using</span>
<span id="cb1-93"><a href="#cb1-93" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-94"><a href="#cb1-94" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-95"><a href="#cb1-95" aria-hidden="true" tabindex="-1"></a>  \theta \mapsto \widehat{C}_t(\theta) := [\hat{\mu}_t - \theta, \hat{\mu}_t + \theta].</span>
<span id="cb1-96"><a href="#cb1-96" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-97"><a href="#cb1-97" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-98"><a href="#cb1-98" aria-hidden="true" tabindex="-1"></a>We refer to this as the _linear interval constructor_. Note that in this case, the radius is simply the absolute residual $r_t = |\hat{\mu}_t - y_t|$.</span>
<span id="cb1-99"><a href="#cb1-99" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-100"><a href="#cb1-100" aria-hidden="true" tabindex="-1"></a><span class="fu">## Quantile Intervals</span></span>
<span id="cb1-101"><a href="#cb1-101" aria-hidden="true" tabindex="-1"></a>The original ACI paper proposed constructing intervals based on the previously observed residuals <span class="co">[</span><span class="ot">@gibbs2021adaptive</span><span class="co">]</span>. Let $S : \mathbb{R}^2 \to \mathbb{R}$ be a function called a _nonconformity score_. A popular choice of nonconformity score is the absolute residual: $(\mu, y) \mapsto  S(\mu, y):= |\mu - y|$.  Let $s_t := S(\hat{\mu}_t, y_t)$ be the nonconformity score of the $t$th-observation. The quantile interval construction function is then given by</span>
<span id="cb1-102"><a href="#cb1-102" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-103"><a href="#cb1-103" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-104"><a href="#cb1-104" aria-hidden="true" tabindex="-1"></a>  \widehat{C}_t(\theta_t) := [\hat{\mu}_t - \mathrm{Quantile}(\theta, \{ s_1, \dots, s_{t-1} \}), \hat{\mu}_t + \mathrm{Quantile}(\theta, \{ s_1, \dots, s_{t-1} <span class="sc">\}</span>)]</span>
<span id="cb1-105"><a href="#cb1-105" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-106"><a href="#cb1-106" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-107"><a href="#cb1-107" aria-hidden="true" tabindex="-1"></a>where $\mathrm{Quantile}(\theta, A)$ denotes the empirical $\theta$-quantile of the elements in the set $A$. Note that $\widehat{C}_t$ is indeed nested in $\theta_t$ because the Quantile function is non-decreasing in $\theta$.</span>
<span id="cb1-108"><a href="#cb1-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-109"><a href="#cb1-109" aria-hidden="true" tabindex="-1"></a>Our proposed <span class="in">`AdaptiveConformal`</span> package takes the absolute residual as the default nonconformity score, although the user may also specify any custom nonconformity score by supplying it as an <span class="in">`R`</span> function.</span>
<span id="cb1-110"><a href="#cb1-110" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-111"><a href="#cb1-111" aria-hidden="true" tabindex="-1"></a><span class="fu">## Online Learning Framework</span></span>
<span id="cb1-112"><a href="#cb1-112" aria-hidden="true" tabindex="-1"></a>We now introduce a loss function that defines the quality of a prediction interval with respect to a realized observation. Define the _pinball loss_ $L^\alpha$ as</span>
<span id="cb1-113"><a href="#cb1-113" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-114"><a href="#cb1-114" aria-hidden="true" tabindex="-1"></a>(\theta, r) \mapsto L^\alpha(\theta, r) := \begin{cases}</span>
<span id="cb1-115"><a href="#cb1-115" aria-hidden="true" tabindex="-1"></a>  \alpha(\theta - r), &amp; \theta \geq r <span class="sc">\\</span></span>
<span id="cb1-116"><a href="#cb1-116" aria-hidden="true" tabindex="-1"></a>  (1-\alpha)(r - \theta), &amp; \theta &lt; r.</span>
<span id="cb1-117"><a href="#cb1-117" aria-hidden="true" tabindex="-1"></a>\end{cases}</span>
<span id="cb1-118"><a href="#cb1-118" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-119"><a href="#cb1-119" aria-hidden="true" tabindex="-1"></a>The way in which the algorithm gains access to the data and incurs losses is as follows:</span>
<span id="cb1-120"><a href="#cb1-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-121"><a href="#cb1-121" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Sequentially, for $t = 1, \dots, T$:</span>
<span id="cb1-122"><a href="#cb1-122" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Predict radius $\theta_t$ and form prediction interval $\widehat{C}_t(\theta_t)$.</span>
<span id="cb1-123"><a href="#cb1-123" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Observe true outcome $y_t$ and calculate radius $r_t$.</span>
<span id="cb1-124"><a href="#cb1-124" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Record $\mathrm{err}_t := \mathbb{I}[y_t \not\in \widehat{C}_t(\theta_t)]$.</span>
<span id="cb1-125"><a href="#cb1-125" aria-hidden="true" tabindex="-1"></a><span class="ss">  - </span>Incur loss $L^\alpha(\theta_t, r_t)$.</span>
<span id="cb1-126"><a href="#cb1-126" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-127"><a href="#cb1-127" aria-hidden="true" tabindex="-1"></a>This iterative procedure is at the core of the online learning theoretical framework in which theoretical results have been derived.</span>
<span id="cb1-128"><a href="#cb1-128" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-129"><a href="#cb1-129" aria-hidden="true" tabindex="-1"></a><span class="fu">## Assessing ACI algorithms</span></span>
<span id="cb1-130"><a href="#cb1-130" aria-hidden="true" tabindex="-1"></a>There are two different perspectives we can take in measuring the quality of an ACI algorithm that generates a sequence $(\theta_t)_{t \in \llbracket T \rrbracket}$. First, we could look at how close the empirical coverage of the generated prediction intervals is to the desired coverage level $\alpha$. Formally, define the empirical coverage as the proportion of observations that fell within the corresponding prediction interval: $\mathrm{EmpCov}(T) := \frac{1}{T} \sum_{t=1}^T (1 - \mathrm{err}_t)$. The coverage error is then given by</span>
<span id="cb1-131"><a href="#cb1-131" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-132"><a href="#cb1-132" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-133"><a href="#cb1-133" aria-hidden="true" tabindex="-1"></a>  \mathrm{CovErr}(T) := \mathrm{EmpCov}(T) - \alpha.</span>
<span id="cb1-134"><a href="#cb1-134" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-135"><a href="#cb1-135" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-136"><a href="#cb1-136" aria-hidden="true" tabindex="-1"></a>The second perspective is to look at how well the algorithm controls the incurred pinball losses. Following the classical framework from the online learning literature, we define the _regret_ as the difference between the cumulative loss yielded by a sequence $(\theta_t)_{t \in \llbracket T \rrbracket}$ versus the cumulative loss of the best possible fixed choice:</span>
<span id="cb1-137"><a href="#cb1-137" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-138"><a href="#cb1-138" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-139"><a href="#cb1-139" aria-hidden="true" tabindex="-1"></a>  \mathrm{Reg}(T) := \sum_{t=1}^T L^\alpha(\theta_t, r_t) - \inf_{\theta^* \in \mathbb{R}} \sum_{t=1}^T L^\alpha(\theta^*, r_t).</span>
<span id="cb1-140"><a href="#cb1-140" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-141"><a href="#cb1-141" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-142"><a href="#cb1-142" aria-hidden="true" tabindex="-1"></a>In settings of distribution shift, it may not be appropriate to compare the cumulative loss of an algorithm to a fixed competitor. As such, stronger notions of regret have been defined. The _strongly adaptive regret_ is the largest regret over any subperiod of length $k \in \llbracket T \rrbracket$:</span>
<span id="cb1-143"><a href="#cb1-143" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-144"><a href="#cb1-144" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-145"><a href="#cb1-145" aria-hidden="true" tabindex="-1"></a>  \mathrm{SAReg}(T, m) := \max_{<span class="co">[</span><span class="ot">\tau, \tau + m - 1</span><span class="co">]</span> \subseteq \llbracket T \rrbracket} \left( \sum_{t=\tau}^{\tau + m - 1} L^{\alpha}(\theta_t, r_t) - \inf_{\theta^* \in \mathbb{R}} \sum_{t=\tau}^{\tau + m - 1} L^\alpha(\theta^*, r_t) \right).</span>
<span id="cb1-146"><a href="#cb1-146" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-147"><a href="#cb1-147" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-148"><a href="#cb1-148" aria-hidden="true" tabindex="-1"></a>Both ways of evaluating ACI methods are important because targeting only one or the other can lead to algorithms that yield prediction intervals that are not practically useful. As a simple pathological example of only targeting the coverage error, suppose we wish to generate $\alpha = 50\%$ prediction intervals. We could choose to alternate $\theta$ between 0 and $\infty$, such that $\mathrm{err}_t$ alternates between 0 and 1. The empirical coverage would then trivially converge to the desired level of 50\%. However, the same algorithm would yield infinite regret (see @bhatnagar2023saocp for a more in-depth example of an scenario in which coverage is optimal but the regret grows linearly). On the other hand, an algorithm that has arbitrarily small regret may not yield good empirical coverage. Suppose the observations and point predictions are constant: $y_t = 1$ and $\hat{\mu}_t = 0$ for all $t \geq 1$. Consider a simple class of algorithms that outputs constantly $\theta_t = \theta'$ for some $\theta' &lt; 1$. With the linear interval construction function, the prediction intervals are then $\widehat{C}_t(\theta_t) = <span class="co">[</span><span class="ot">-\theta', \theta'</span><span class="co">]</span>$. The regret is given by $\mathrm{Reg}(T) = 2T\alpha(1-\theta')$, which approaches zero as $\theta'$ approaches 1. The empirical coverage is, however, always zero. In other words, the regret can be arbitrarily close to zero while at the same time the empirical coverage does not approach the desired level. </span>
<span id="cb1-149"><a href="#cb1-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-150"><a href="#cb1-150" aria-hidden="true" tabindex="-1"></a>These simple examples illustrate that, unfortunately, bounds on the coverage error and bounds on the regret are not in general interchangeable. It is possible, however, to show equivalencies by either (1) making distributional assumptions on the data or (2) using additional information about how the algorithm produces the sequence $(\theta_t)_{t \in \llbracket T \rrbracket}$ <span class="co">[</span><span class="ot">@bhatnagar2023saocp</span><span class="co">]</span>.</span>
<span id="cb1-151"><a href="#cb1-151" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-152"><a href="#cb1-152" aria-hidden="true" tabindex="-1"></a>It may also be informative to summarize a set of prediction intervals in ways beyond their coverage error or their regret. A common metric for prediction intervals is the _mean interval width_:</span>
<span id="cb1-153"><a href="#cb1-153" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-154"><a href="#cb1-154" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-155"><a href="#cb1-155" aria-hidden="true" tabindex="-1"></a>  \mathrm{MeanWidth}(T) := \frac{1}{T} \sum_{t=1}^T w_t,</span>
<span id="cb1-156"><a href="#cb1-156" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-157"><a href="#cb1-157" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-158"><a href="#cb1-158" aria-hidden="true" tabindex="-1"></a>where $w_t := u_t - \ell_t$ is the interval width at time $t$. </span>
<span id="cb1-159"><a href="#cb1-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-160"><a href="#cb1-160" aria-hidden="true" tabindex="-1"></a>Finally, we introduce a metric that is intended to capture pathological behavior that can arise with ACI algorithms where the prediction intervals oscillate between being extremely narrow and extremely wide. Define the _path length_ of prediction intervals generated by an ACI algorithm as</span>
<span id="cb1-161"><a href="#cb1-161" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-162"><a href="#cb1-162" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-163"><a href="#cb1-163" aria-hidden="true" tabindex="-1"></a>  \mathrm{PathLength}(T) := \sum_{t=2}^T |w_t - w_{t-1}|.</span>
<span id="cb1-164"><a href="#cb1-164" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-165"><a href="#cb1-165" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-166"><a href="#cb1-166" aria-hidden="true" tabindex="-1"></a>A high path length indicates that the prediction intervals were variable over time, and a low path length indicates the prediction intervals were stable. </span>
<span id="cb1-167"><a href="#cb1-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-168"><a href="#cb1-168" aria-hidden="true" tabindex="-1"></a><span class="fu"># Algorithms {#sec-algorithms}</span></span>
<span id="cb1-169"><a href="#cb1-169" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-170"><a href="#cb1-170" aria-hidden="true" tabindex="-1"></a>| Algorithm                                             | Tuning Parameters                                           | Original interval constructor | Citation            |</span>
<span id="cb1-171"><a href="#cb1-171" aria-hidden="true" tabindex="-1"></a>| ------------------------------------------------------|-------------------------------------------------------------|---------------------|</span>
<span id="cb1-172"><a href="#cb1-172" aria-hidden="true" tabindex="-1"></a>| Adaptive Conformal Inference (ACI)                    | Learning rate $\gamma$                                      | Quantile | @gibbs2021adaptive  |</span>
<span id="cb1-173"><a href="#cb1-173" aria-hidden="true" tabindex="-1"></a>| Aggregated Adaptive Conformal Inference (AgACI)       | Candidate learning rates $(\gamma_k)_{1 \leq k \leq K}$ | Quantile | @zaffran2022agaci   |</span>
<span id="cb1-174"><a href="#cb1-174" aria-hidden="true" tabindex="-1"></a>| Fully Adaptive Conformal Inference (FACI)             | Candidate learning rates $(\gamma_k)_{1 \leq k \leq K}$ | Quantile | @gibbs2022faci      |</span>
<span id="cb1-175"><a href="#cb1-175" aria-hidden="true" tabindex="-1"></a>| Scale-Free Online Gradient Descent (SF-OGD)           | Learning rate $\gamma$ or maximum radius $D$             | Linear | @bhatnagar2023saocp |</span>
<span id="cb1-176"><a href="#cb1-176" aria-hidden="true" tabindex="-1"></a>| Strongly Adaptive Online Conformal Prediction (SAOCP) | Learning rate $\gamma$, lifetime multiplier $g$          | Linear | @bhatnagar2023saocp |</span>
<span id="cb1-177"><a href="#cb1-177" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-178"><a href="#cb1-178" aria-hidden="true" tabindex="-1"></a>  : Summary of ACI algorithms {#tbl-aci}</span>
<span id="cb1-179"><a href="#cb1-179" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-180"><a href="#cb1-180" aria-hidden="true" tabindex="-1"></a>As a simple running example to illustrate each algorithm, we simulate independently $T = 500$ values $y_1, \dots, y_T$ following</span>
<span id="cb1-181"><a href="#cb1-181" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-182"><a href="#cb1-182" aria-hidden="true" tabindex="-1"></a>y_t \sim N(0, 0.2^2), \quad t \in \llbracket T \rrbracket.</span>
<span id="cb1-183"><a href="#cb1-183" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-184"><a href="#cb1-184" aria-hidden="true" tabindex="-1"></a>For demonstration purposes we assume we have access to unbiased predictions $\hat{\mu}_t = 0$ for all $t \in \llbracket T \rrbracket$. Throughout we set the target empirical coverage to $\alpha = 0.8$.</span>
<span id="cb1-185"><a href="#cb1-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-186"><a href="#cb1-186" aria-hidden="true" tabindex="-1"></a><span class="in">```{r example_setup, echo = FALSE}</span></span>
<span id="cb1-187"><a href="#cb1-187" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(AdaptiveConformal)</span>
<span id="cb1-188"><a href="#cb1-188" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">15321</span>)</span>
<span id="cb1-189"><a href="#cb1-189" aria-hidden="true" tabindex="-1"></a>N <span class="ot">&lt;-</span> <span class="fl">5e2</span></span>
<span id="cb1-190"><a href="#cb1-190" aria-hidden="true" tabindex="-1"></a>mu <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>, N)</span>
<span id="cb1-191"><a href="#cb1-191" aria-hidden="true" tabindex="-1"></a>muhat <span class="ot">&lt;-</span> mu</span>
<span id="cb1-192"><a href="#cb1-192" aria-hidden="true" tabindex="-1"></a>y <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(N, <span class="at">mean =</span> mu, <span class="at">sd =</span> <span class="fl">0.2</span>)</span>
<span id="cb1-193"><a href="#cb1-193" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-194"><a href="#cb1-194" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-195"><a href="#cb1-195" aria-hidden="true" tabindex="-1"></a><span class="fu">## Adaptive Conformal Inference (ACI)</span></span>
<span id="cb1-196"><a href="#cb1-196" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-197"><a href="#cb1-197" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb1-198"><a href="#cb1-198" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: algo-aci</span></span>
<span id="cb1-199"><a href="#cb1-199" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb1-200"><a href="#cb1-200" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb1-201"><a href="#cb1-201" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb1-202"><a href="#cb1-202" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb1-203"><a href="#cb1-203" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb1-204"><a href="#cb1-204" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb1-205"><a href="#cb1-205" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb1-206"><a href="#cb1-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-207"><a href="#cb1-207" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb1-208"><a href="#cb1-208" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Adaptive Conformal Inference}</span></span>
<span id="cb1-209"><a href="#cb1-209" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb1-210"><a href="#cb1-210" aria-hidden="true" tabindex="-1"></a><span class="in">\State \textbf{Input:} starting value $\theta_1$, learning rate $\gamma &gt; 0$.</span></span>
<span id="cb1-211"><a href="#cb1-211" aria-hidden="true" tabindex="-1"></a><span class="in">\For{$t = 1, 2, \dots, T$}</span></span>
<span id="cb1-212"><a href="#cb1-212" aria-hidden="true" tabindex="-1"></a><span class="in">  \State \textbf{Output:} prediction interval $\widehat{C}_t(\theta_t)$.</span></span>
<span id="cb1-213"><a href="#cb1-213" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Observe $y_t$.</span></span>
<span id="cb1-214"><a href="#cb1-214" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Evaluate $\mathrm{err}_t = \mathbb{I}[y_t \not\in \widehat{C}_t(\theta_t)]$.</span></span>
<span id="cb1-215"><a href="#cb1-215" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Update $\theta_{t+1} = \theta_t + \gamma (\mathrm{err}_t - (1 - \alpha))$.</span></span>
<span id="cb1-216"><a href="#cb1-216" aria-hidden="true" tabindex="-1"></a><span class="in">\EndFor</span></span>
<span id="cb1-217"><a href="#cb1-217" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb1-218"><a href="#cb1-218" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb1-219"><a href="#cb1-219" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-220"><a href="#cb1-220" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-221"><a href="#cb1-221" aria-hidden="true" tabindex="-1"></a>The original ACI algorithm (@gibbs2021adaptive; @algo-aci) adaptively adjusts the width of the prediction intervals in response to the observations. The updating rule for the estimated radius can be derived as an online subgradient descent scheme. The subgradient of the pinball loss function with respect to $\theta$ is given by</span>
<span id="cb1-222"><a href="#cb1-222" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-223"><a href="#cb1-223" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-224"><a href="#cb1-224" aria-hidden="true" tabindex="-1"></a>  \nabla L^\alpha(\theta, r) &amp;= \begin{cases}</span>
<span id="cb1-225"><a href="#cb1-225" aria-hidden="true" tabindex="-1"></a>    <span class="sc">\{</span> -\alpha <span class="sc">\}</span>, &amp;\theta &lt; r, <span class="sc">\\</span></span>
<span id="cb1-226"><a href="#cb1-226" aria-hidden="true" tabindex="-1"></a>    <span class="sc">\{</span> 1 - \alpha <span class="sc">\}</span>, &amp; \theta &gt; r, <span class="sc">\\</span></span>
<span id="cb1-227"><a href="#cb1-227" aria-hidden="true" tabindex="-1"></a>    <span class="co">[</span><span class="ot">-\alpha, 1 - \alpha</span><span class="co">]</span>, &amp;\theta = r</span>
<span id="cb1-228"><a href="#cb1-228" aria-hidden="true" tabindex="-1"></a>  \end{cases} <span class="sc">\\</span></span>
<span id="cb1-229"><a href="#cb1-229" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-230"><a href="#cb1-230" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-231"><a href="#cb1-231" aria-hidden="true" tabindex="-1"></a>It follows that, for all $\theta_t \in \mathbb{R}$ and $r_t \in \mathbb{R}$,</span>
<span id="cb1-232"><a href="#cb1-232" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-233"><a href="#cb1-233" aria-hidden="true" tabindex="-1"></a>1 - \alpha - \mathrm{err}_t \in \nabla L^\alpha(\theta_t, r_t).</span>
<span id="cb1-234"><a href="#cb1-234" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-235"><a href="#cb1-235" aria-hidden="true" tabindex="-1"></a>This leads to the following update rule for $\theta$ based on subgradient descent:</span>
<span id="cb1-236"><a href="#cb1-236" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-237"><a href="#cb1-237" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-238"><a href="#cb1-238" aria-hidden="true" tabindex="-1"></a>  \theta_{t+1} = \theta_{t} + \gamma (\mathrm{err}_t - (1 - \alpha)),</span>
<span id="cb1-239"><a href="#cb1-239" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-240"><a href="#cb1-240" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-241"><a href="#cb1-241" aria-hidden="true" tabindex="-1"></a>where $\gamma &gt; 0$ is a user-specified learning rate. For intuition, note that if $y_t$ fell outside of the prediction interval at time $t$ ($\mathrm{err}_t = 1$) then the next interval is widened ($\theta_{t+1} = \theta_t + \gamma \alpha$). On the contrary, if $y_t$ fell within the interval ($\mathrm{err}_t = 0$) then the next interval is shortened ($\theta_{t+1} = \theta_t - \gamma(1 - \alpha)$). The learning rate $\gamma$ controls how fast the width of the prediction intervals changes in response to the data. </span>
<span id="cb1-242"><a href="#cb1-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-243"><a href="#cb1-243" aria-hidden="true" tabindex="-1"></a><span class="fu">### Theoretical Guarantees</span></span>
<span id="cb1-244"><a href="#cb1-244" aria-hidden="true" tabindex="-1"></a>The ACI algorithm has the following finite sample bound on the coverage error  <span class="co">[</span><span class="ot">@gibbs2021adaptive</span><span class="co">]</span>. For all $\gamma &gt; 0$, </span>
<span id="cb1-245"><a href="#cb1-245" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-246"><a href="#cb1-246" aria-hidden="true" tabindex="-1"></a>|\mathrm{CovErr}(T)| \leq \frac{D + \gamma}{\gamma T}.</span>
<span id="cb1-247"><a href="#cb1-247" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-248"><a href="#cb1-248" aria-hidden="true" tabindex="-1"></a>This result was originally shown for ACI with the choice of the quantile interval constructor, although it can also be extended to other interval constructors <span class="co">[</span><span class="ot">@bhatnagar2023saocp, @feldman2023achieving</span><span class="co">]</span>. In addition, standard results for online subgradient descent yield the following regret bound with the use of the linear interval constructor, assuming that the true radii are bounded by $D$:</span>
<span id="cb1-249"><a href="#cb1-249" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-250"><a href="#cb1-250" aria-hidden="true" tabindex="-1"></a>\mathrm{Reg}(T) \leq \mathcal{O}(D^2 / \gamma + \gamma T) \leq \mathcal{O}(D \sqrt{T}),</span>
<span id="cb1-251"><a href="#cb1-251" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-252"><a href="#cb1-252" aria-hidden="true" tabindex="-1"></a>where the second inequality follows if the optimal choice of $\gamma = D/\sqrt{T}$ is used <span class="co">[</span><span class="ot">@bhatnagar2023saocp</span><span class="co">]</span>. Taken together, these theoretical results imply that while the coverage error is guaranteed to converge to zero for any choice of $\gamma$, achieving sublinear regret requires choosing $\gamma$ more carefully. This highlights the importance of both ways of assessing ACI algorithms: if we only focused on controlling the coverage error, we might not achieve optimal control of regret, leading to intervals that are not practically useful. </span>
<span id="cb1-253"><a href="#cb1-253" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-254"><a href="#cb1-254" aria-hidden="true" tabindex="-1"></a><span class="fu">### Tuning Parameters</span></span>
<span id="cb1-255"><a href="#cb1-255" aria-hidden="true" tabindex="-1"></a>Therefore, the main tuning parameter is the learning rate $\gamma$. The theoretical bounds on the coverage error suggest setting a large $\gamma$ such that the coverage error decays quickly in $T$; however, in practice and setting $\gamma$ too large will lead to intervals with large oscillations as seen in @fig-aci. This is quantified in the path length, which increases significantly as $\gamma$ increases, even though the empirical coverage remains near the desired value of 80\%.  On the other hand, setting $\gamma$ too small will lead to intervals that do not adapt fast enough to distribution shifts. Thus, choosing a good value for $\gamma$ is essential. However, the optimal choice $\gamma = D / \sqrt{T}$ cannot be used directly in practice unless the time series length $T$ is fixed in advance, or the so called "doubling trick" is used to relax the need to know $T$ in advance <span class="co">[</span><span class="ot">@cesabianchi2006games</span><span class="co">]</span>.</span>
<span id="cb1-256"><a href="#cb1-256" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-257"><a href="#cb1-257" aria-hidden="true" tabindex="-1"></a>The theoretical results guaranteeing the performance of the ACI algorithm do not depend on the choice of starting value $\theta_1$, and thus in practice any value can be chosen. Indeed, the effect of the choice of $\theta_1$ decays over time as a function of the chosen learning rate. In practice, substantive prior information can be used to pick a reasonable starting value. By default, the <span class="in">`AdaptiveConformal`</span> package sets $\theta_1 = \alpha$ when the quantile interval predictor is used, and $\theta_1 = 0$ otherwise, although in both cases the user can supply their own starting value. The behavior of the early prediction intervals in the examples (@fig-aci) is driven by the small number of residuals available, which makes the output of the quantile interval constructor sensitive to small changes in $\theta$. In practice, a warm-up period can be used before starting to produce prediction intervals so that the quantiles of the residuals are more stable.</span>
<span id="cb1-258"><a href="#cb1-258" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-259"><a href="#cb1-259" aria-hidden="true" tabindex="-1"></a><span class="in">```{r aci_example_plot, echo = FALSE}</span></span>
<span id="cb1-260"><a href="#cb1-260" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-aci</span></span>
<span id="cb1-261"><a href="#cb1-261" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 4.5</span></span>
<span id="cb1-262"><a href="#cb1-262" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Example 80% prediction intervals from the ACI algorithm for different choices of learning rate $\\gamma$ and with $\\theta_1 = 0.8$. Blue and red points are observations that fell inside and outside the prediction intervals, respectively."</span></span>
<span id="cb1-263"><a href="#cb1-263" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> <span class="fl">0.8</span></span>
<span id="cb1-264"><a href="#cb1-264" aria-hidden="true" tabindex="-1"></a>gamma_grid <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.016</span>, <span class="fl">0.032</span>, <span class="fl">0.064</span>, <span class="fl">0.128</span>)</span>
<span id="cb1-265"><a href="#cb1-265" aria-hidden="true" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb1-266"><a href="#cb1-266" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"ACI"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">interval_constructor =</span> <span class="st">"conformal"</span>, <span class="at">theta0 =</span> alpha, <span class="at">gamma =</span> gamma_grid[<span class="dv">1</span>])),</span>
<span id="cb1-267"><a href="#cb1-267" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"ACI"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">interval_constructor =</span> <span class="st">"conformal"</span>, <span class="at">theta0 =</span> alpha, <span class="at">gamma =</span> gamma_grid[<span class="dv">2</span>])),</span>
<span id="cb1-268"><a href="#cb1-268" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"ACI"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">interval_constructor =</span> <span class="st">"conformal"</span>, <span class="at">theta0 =</span> alpha, <span class="at">gamma =</span> gamma_grid[<span class="dv">3</span>])),</span>
<span id="cb1-269"><a href="#cb1-269" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"ACI"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">interval_constructor =</span> <span class="st">"conformal"</span>, <span class="at">theta0 =</span> alpha, <span class="at">gamma =</span> gamma_grid[<span class="dv">4</span>]))</span>
<span id="cb1-270"><a href="#cb1-270" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-271"><a href="#cb1-271" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-272"><a href="#cb1-272" aria-hidden="true" tabindex="-1"></a>coverage    <span class="ot">&lt;-</span> <span class="fu">format_coverage</span>(<span class="fu">extract_metric</span>(results, <span class="st">"coverage"</span>))</span>
<span id="cb1-273"><a href="#cb1-273" aria-hidden="true" tabindex="-1"></a>path_length <span class="ot">&lt;-</span> <span class="fu">format_path_length</span>(<span class="fu">extract_metric</span>(results, <span class="st">"path_length"</span>))</span>
<span id="cb1-274"><a href="#cb1-274" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-275"><a href="#cb1-275" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>))</span>
<span id="cb1-276"><a href="#cb1-276" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>) {</span>
<span id="cb1-277"><a href="#cb1-277" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot</span>(results[[i]], <span class="at">legend =</span> <span class="cn">FALSE</span>, <span class="at">predictions =</span> <span class="cn">FALSE</span>, <span class="at">cex =</span> <span class="fl">0.5</span>, <span class="at">main =</span> <span class="fu">bquote</span>(gamma<span class="sc">==</span>.(results[[i]]<span class="sc">$</span>parameters<span class="sc">$</span>gamma)), <span class="at">ylim =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.9</span>, <span class="fl">0.8</span>))</span>
<span id="cb1-278"><a href="#cb1-278" aria-hidden="true" tabindex="-1"></a>  <span class="fu">text</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">0.75</span>, <span class="at">labels =</span> <span class="fu">bquote</span>(EmpCov <span class="sc">==</span> .(coverage[[i]]) ), <span class="at">pos =</span> <span class="dv">4</span>)</span>
<span id="cb1-279"><a href="#cb1-279" aria-hidden="true" tabindex="-1"></a>  <span class="fu">text</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">0.9</span>, <span class="at">labels =</span> <span class="fu">bquote</span>(PathLength <span class="sc">==</span> .(path_length[[i]]) ), <span class="at">pos =</span> <span class="dv">4</span>)</span>
<span id="cb1-280"><a href="#cb1-280" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-281"><a href="#cb1-281" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="fl">5.1</span>, <span class="fl">4.1</span>, <span class="fl">4.1</span>, <span class="fl">2.1</span>))</span>
<span id="cb1-282"><a href="#cb1-282" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-283"><a href="#cb1-283" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-284"><a href="#cb1-284" aria-hidden="true" tabindex="-1"></a><span class="fu">## Aggregated Adaptive Conformal Inference (AgACI)</span></span>
<span id="cb1-285"><a href="#cb1-285" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb1-286"><a href="#cb1-286" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: algo-agaci</span></span>
<span id="cb1-287"><a href="#cb1-287" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb1-288"><a href="#cb1-288" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb1-289"><a href="#cb1-289" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb1-290"><a href="#cb1-290" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb1-291"><a href="#cb1-291" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb1-292"><a href="#cb1-292" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb1-293"><a href="#cb1-293" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb1-294"><a href="#cb1-294" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-295"><a href="#cb1-295" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb1-296"><a href="#cb1-296" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Aggregated Adaptive Conformal Inference}</span></span>
<span id="cb1-297"><a href="#cb1-297" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb1-298"><a href="#cb1-298" aria-hidden="true" tabindex="-1"></a><span class="in">  \State \textbf{Input:} candidate learning rates $(\gamma_k)_{1 \leq k \leq K }$, starting value $\theta_1$.</span></span>
<span id="cb1-299"><a href="#cb1-299" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Initialize lower and upper BOA algorithms $\mathcal{B}^\ell := \texttt{BOA}(\alpha \leftarrow (1 - \alpha) / 2)$ and $\mathcal{B}^u := \texttt{BOA}(\alpha \leftarrow (1 - (1 - \alpha)/2))$.</span></span>
<span id="cb1-300"><a href="#cb1-300" aria-hidden="true" tabindex="-1"></a><span class="in">  \For{$k = 1, \dots, K$}</span></span>
<span id="cb1-301"><a href="#cb1-301" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Initialize ACI $\mathcal{A}_k = \texttt{ACI}(\alpha \leftarrow \alpha, \gamma \leftarrow \gamma_k, \theta_1 \leftarrow \theta_1)$.</span></span>
<span id="cb1-302"><a href="#cb1-302" aria-hidden="true" tabindex="-1"></a><span class="in">  \EndFor</span></span>
<span id="cb1-303"><a href="#cb1-303" aria-hidden="true" tabindex="-1"></a><span class="in">  \For{$t = 1, 2, \dots, T$}</span></span>
<span id="cb1-304"><a href="#cb1-304" aria-hidden="true" tabindex="-1"></a><span class="in">    \For{$k = 1, \dots, K$}</span></span>
<span id="cb1-305"><a href="#cb1-305" aria-hidden="true" tabindex="-1"></a><span class="in">      \State Retrieve candidate prediction interval $[\ell^k_{t}, u^k_{t}]$ from $\mathcal{A}_k$.</span></span>
<span id="cb1-306"><a href="#cb1-306" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndFor</span></span>
<span id="cb1-307"><a href="#cb1-307" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Compute aggregated lower bound $\tilde{\ell}_t := \mathcal{B}^\ell((\ell^k_t : k \in \{ 1, \dots, K \}))$.</span></span>
<span id="cb1-308"><a href="#cb1-308" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Compute aggregated upper bound $\tilde{u}_t := \mathcal{B}^u((u^k_t : k \in \{ 1, \dots, K \}))$.</span></span>
<span id="cb1-309"><a href="#cb1-309" aria-hidden="true" tabindex="-1"></a><span class="in">    \State \textbf{Output:} prediction interval $[\tilde{\ell}_t, \tilde{u}_t]$.</span></span>
<span id="cb1-310"><a href="#cb1-310" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Observe $y_t$.</span></span>
<span id="cb1-311"><a href="#cb1-311" aria-hidden="true" tabindex="-1"></a><span class="in">    \For{$k = 1, \dots, K$}</span></span>
<span id="cb1-312"><a href="#cb1-312" aria-hidden="true" tabindex="-1"></a><span class="in">      \State Update $\mathcal{A}_k$ with observation $y_t$.</span></span>
<span id="cb1-313"><a href="#cb1-313" aria-hidden="true" tabindex="-1"></a><span class="in">    \EndFor</span></span>
<span id="cb1-314"><a href="#cb1-314" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Update $\mathcal{B}^\ell$ with observed outcome $y_t$. </span></span>
<span id="cb1-315"><a href="#cb1-315" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Update $\mathcal{B}^u$ with observed outcome $y_t$.</span></span>
<span id="cb1-316"><a href="#cb1-316" aria-hidden="true" tabindex="-1"></a><span class="in">  \EndFor</span></span>
<span id="cb1-317"><a href="#cb1-317" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb1-318"><a href="#cb1-318" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb1-319"><a href="#cb1-319" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-320"><a href="#cb1-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-321"><a href="#cb1-321" aria-hidden="true" tabindex="-1"></a>The Aggregated ACI (AgACI; @algo-agaci) algorithm solves the problem of choosing a learning rate for ACI by running multiple copies of the algorithm with different learning rates, and then separately combining the lower and upper interval bounds using an online aggregation of experts algorithm <span class="co">[</span><span class="ot">@zaffran2022agaci</span><span class="co">]</span>. That is, one aggregation algorithm seeks to estimate the lower $(1-\alpha)/2$ quantile, and the other seeks to estimate the upper $1 - (1 - \alpha) / 2$ quantile. @zaffran2022agaci experimented with multiple online aggregation algorithms, and found that they yielded similar results. Thus, we follow their lead in using the Bernstein Online Aggregation (BOA) algorithm as implemented in the <span class="in">`opera`</span> <span class="in">`R`</span> package <span class="co">[</span><span class="ot">@wintenberger2017boa; @opera2023</span><span class="co">]</span>. BOA is an online algorithm that forms predictions for the lower (or upper) prediction interval bound as a weighted mean of the candidate ACI prediction interval lower (upper) bound, where the weights are determined by each candidate's past performance with respect to the quantile loss. As a consequence, the prediction intervals generated by AgACI are not necessarily symmetric around the point prediction, as the weights for the lower and upper bounds are separate.</span>
<span id="cb1-322"><a href="#cb1-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-323"><a href="#cb1-323" aria-hidden="true" tabindex="-1"></a><span class="fu">### Theoretical Gaurantees</span></span>
<span id="cb1-324"><a href="#cb1-324" aria-hidden="true" tabindex="-1"></a>AgACI departs from our main theoretical framework in that it does not yield a sequence $(\theta_t)_{t \in \llbracket T \rrbracket}$ whose elements yield prediction intervals via a set construction function $\widehat{C}_t$. Rather, the upper and lower interval bounds from a set of candidate ACI algorithms are aggregated separately. Thus, theoretical results such as regret bounds similar to those for the other algorithms are not available. It would be possible, however, to establish regret bounds for the pinball loss applied separately to the lower and upper bounds of the prediction intervals. It is unclear, however, how to convert such regret bounds into a coverage bound.</span>
<span id="cb1-325"><a href="#cb1-325" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-326"><a href="#cb1-326" aria-hidden="true" tabindex="-1"></a><span class="fu">### Tuning Parameters</span></span>
<span id="cb1-327"><a href="#cb1-327" aria-hidden="true" tabindex="-1"></a>The main tuning parameter for AgACI is the set of candidate learning rates. Beyond necessitating additional computational time, there is no drawback to having a large grid. As a default, <span class="in">`AdaptiveConformal`</span> uses learning rates $\gamma \in <span class="sc">\{</span> 0.001, 0.002, 0.004, 0.008, 0.016, 0.032, 0.064, 0.128 <span class="sc">\}</span>$. As a basic check, we can look at the weights assigned to each of the learning rates. If large weights are given to the smallest (largest) learning rates, it is a sign that smaller (or larger) learning rates may perform well. In addition each of the candidate ACI algorithms requires a starting value, which can be set to any value as discussed in the ACI section. @fig-agaci illustrates AgACI applied to the running example with two sets of learning grids. The first grid is the default, and the second grid includes the additional value $\gamma = <span class="sc">\{</span> 0.0005 <span class="sc">\}</span>$. For the first grid, we can see that for the lower bound AgACI assigns high weight to the lowest learning rate ($\gamma = 0.001$). Based on this observation, as a sensitivity check, we reran the algorithm with the second learning grid, which yields weights that are less concentrated on a single learning rate. The output prediction intervals are similar, although slightly smoother in the second grid, reflecting the lack of distributional shift in the simulated data. </span>
<span id="cb1-328"><a href="#cb1-328" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-329"><a href="#cb1-329" aria-hidden="true" tabindex="-1"></a><span class="in">```{r agaci_example_plot, echo = FALSE}</span></span>
<span id="cb1-330"><a href="#cb1-330" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-agaci</span></span>
<span id="cb1-331"><a href="#cb1-331" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 4.5</span></span>
<span id="cb1-332"><a href="#cb1-332" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Example 80% prediction intervals from the AgACI algorithm with starting values $\\theta_1 = 0.8$ and two different learning rate grids, where the second grid is double the size of the first. In the left column, blue and red points are observations that fell inside and outside the prediction intervals, respectively."</span></span>
<span id="cb1-333"><a href="#cb1-333" aria-hidden="true" tabindex="-1"></a>grid1 <span class="ot">&lt;-</span> <span class="dv">2</span><span class="sc">^</span>(<span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">7</span>, <span class="dv">1</span>)) <span class="sc">/</span> <span class="fl">1e3</span></span>
<span id="cb1-334"><a href="#cb1-334" aria-hidden="true" tabindex="-1"></a>grid2 <span class="ot">&lt;-</span> <span class="dv">2</span><span class="sc">^</span>(<span class="fu">seq</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">1</span>)) <span class="sc">/</span> <span class="fl">1e3</span></span>
<span id="cb1-335"><a href="#cb1-335" aria-hidden="true" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb1-336"><a href="#cb1-336" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"AgACI"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">interval_constructor =</span> <span class="st">"conformal"</span>, <span class="at">gamma_grid =</span> grid1, <span class="at">theta0 =</span> <span class="fl">0.8</span>)),</span>
<span id="cb1-337"><a href="#cb1-337" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"AgACI"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">interval_constructor =</span> <span class="st">"conformal"</span>, <span class="at">gamma_grid =</span> grid2, <span class="at">theta0 =</span> <span class="fl">0.8</span>))</span>
<span id="cb1-338"><a href="#cb1-338" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-339"><a href="#cb1-339" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-340"><a href="#cb1-340" aria-hidden="true" tabindex="-1"></a>coverage    <span class="ot">&lt;-</span> <span class="fu">format_coverage</span>(<span class="fu">extract_metric</span>(results, <span class="st">"coverage"</span>))</span>
<span id="cb1-341"><a href="#cb1-341" aria-hidden="true" tabindex="-1"></a>path_length <span class="ot">&lt;-</span> <span class="fu">format_path_length</span>(<span class="fu">extract_metric</span>(results, <span class="st">"path_length"</span>))</span>
<span id="cb1-342"><a href="#cb1-342" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-343"><a href="#cb1-343" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>))</span>
<span id="cb1-344"><a href="#cb1-344" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">2</span>) {</span>
<span id="cb1-345"><a href="#cb1-345" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot</span>(results[[i]], <span class="at">legend =</span> <span class="cn">FALSE</span>, <span class="at">predictions =</span> <span class="cn">FALSE</span>, <span class="at">cex =</span> <span class="fl">0.5</span>, <span class="at">main =</span> <span class="fu">paste</span>(<span class="st">"Grid"</span>, i), <span class="at">ylim =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.9</span>, <span class="fl">0.8</span>))</span>
<span id="cb1-346"><a href="#cb1-346" aria-hidden="true" tabindex="-1"></a>  <span class="fu">text</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">0.75</span>, <span class="at">labels =</span> <span class="fu">bquote</span>(EmpCov <span class="sc">==</span> .(coverage[[i]]) ), <span class="at">pos =</span> <span class="dv">4</span>)</span>
<span id="cb1-347"><a href="#cb1-347" aria-hidden="true" tabindex="-1"></a>  <span class="fu">text</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">0.9</span>, <span class="at">labels =</span> <span class="fu">bquote</span>(PathLength <span class="sc">==</span> .(path_length[[i]]) ), <span class="at">pos =</span> <span class="dv">4</span>)</span>
<span id="cb1-348"><a href="#cb1-348" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-349"><a href="#cb1-349" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot_agaci_weights</span>(results[[i]], <span class="at">main =</span> <span class="st">"Final Aggregation Weights"</span>, <span class="at">legend =</span> <span class="st">"topright"</span>)</span>
<span id="cb1-350"><a href="#cb1-350" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-351"><a href="#cb1-351" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="fl">5.1</span>, <span class="fl">4.1</span>, <span class="fl">4.1</span>, <span class="fl">2.1</span>))</span>
<span id="cb1-352"><a href="#cb1-352" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-353"><a href="#cb1-353" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-354"><a href="#cb1-354" aria-hidden="true" tabindex="-1"></a><span class="in">```{r agaci_example_plot2, echo = FALSE}</span></span>
<span id="cb1-355"><a href="#cb1-355" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-agaci2</span></span>
<span id="cb1-356"><a href="#cb1-356" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 3</span></span>
<span id="cb1-357"><a href="#cb1-357" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Weights assigned to each of the candidate ACI algorithms by AgACI at the final timepoint."</span></span>
<span id="cb1-358"><a href="#cb1-358" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-359"><a href="#cb1-359" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-360"><a href="#cb1-360" aria-hidden="true" tabindex="-1"></a><span class="fu">## Fully Adaptive Conformal Inference (FACI)</span></span>
<span id="cb1-361"><a href="#cb1-361" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb1-362"><a href="#cb1-362" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: algo-faci</span></span>
<span id="cb1-363"><a href="#cb1-363" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb1-364"><a href="#cb1-364" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb1-365"><a href="#cb1-365" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb1-366"><a href="#cb1-366" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb1-367"><a href="#cb1-367" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb1-368"><a href="#cb1-368" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb1-369"><a href="#cb1-369" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb1-370"><a href="#cb1-370" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-371"><a href="#cb1-371" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb1-372"><a href="#cb1-372" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Fully Adaptive Conformal Inference}</span></span>
<span id="cb1-373"><a href="#cb1-373" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb1-374"><a href="#cb1-374" aria-hidden="true" tabindex="-1"></a><span class="in">\State \textbf{Input:} starting value $\theta_1$, candidate learning rates $(\gamma_k)_{1 \leq k \leq K }$, parameters $\sigma, \eta$.</span></span>
<span id="cb1-375"><a href="#cb1-375" aria-hidden="true" tabindex="-1"></a><span class="in">\For{$k = 1, \dots, K$}</span></span>
<span id="cb1-376"><a href="#cb1-376" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Initialize expert $\mathcal{A}_k = \texttt{ACI}(\alpha \leftarrow \alpha, \gamma \leftarrow \gamma_k, \theta_1 \leftarrow \theta_1)$.</span></span>
<span id="cb1-377"><a href="#cb1-377" aria-hidden="true" tabindex="-1"></a><span class="in">\EndFor</span></span>
<span id="cb1-378"><a href="#cb1-378" aria-hidden="true" tabindex="-1"></a><span class="in">\For{$t = 1, 2, \dots, T$}</span></span>
<span id="cb1-379"><a href="#cb1-379" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Define $p_t^k := w_t^k / \sum_{i=1}^K w_t^i$, for all $1 \leq k \leq K$.</span></span>
<span id="cb1-380"><a href="#cb1-380" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Set $\theta_t = \sum_{k=1}^K \theta_t^k p_t^k$.</span></span>
<span id="cb1-381"><a href="#cb1-381" aria-hidden="true" tabindex="-1"></a><span class="in">  \State \textbf{Output:} prediction interval $\widehat{C}_t(\theta_t)$.</span></span>
<span id="cb1-382"><a href="#cb1-382" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Observe $y_t$ and compute $r_t$.</span></span>
<span id="cb1-383"><a href="#cb1-383" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\bar{w}_{t}^k \gets w_t^k \exp(-\eta L^\alpha(\theta_t^k, r_t))$, for all $1 \leq k \leq K$.</span></span>
<span id="cb1-384"><a href="#cb1-384" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $\bar{W}_t \gets \sum_{i=1}^K \bar{w}_t^i$.</span></span>
<span id="cb1-385"><a href="#cb1-385" aria-hidden="true" tabindex="-1"></a><span class="in">  \State $w_{t+1}^k \gets (1 - \sigma) \bar{w}_t^k + \bar{W}_t \sigma / K$.</span></span>
<span id="cb1-386"><a href="#cb1-386" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Set $\mathrm{err}_t := \mathbb{I}[y_t \not\in \widehat{C}_t(\theta_t)]$.</span></span>
<span id="cb1-387"><a href="#cb1-387" aria-hidden="true" tabindex="-1"></a><span class="in">  \For{$k = 1, \dots, K$}</span></span>
<span id="cb1-388"><a href="#cb1-388" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Update ACI $\mathcal{A}_k$ with $y_t$ and obtain $\theta_{t+1}^k$.</span></span>
<span id="cb1-389"><a href="#cb1-389" aria-hidden="true" tabindex="-1"></a><span class="in">  \EndFor</span></span>
<span id="cb1-390"><a href="#cb1-390" aria-hidden="true" tabindex="-1"></a><span class="in">\EndFor</span></span>
<span id="cb1-391"><a href="#cb1-391" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb1-392"><a href="#cb1-392" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb1-393"><a href="#cb1-393" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-394"><a href="#cb1-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-395"><a href="#cb1-395" aria-hidden="true" tabindex="-1"></a>The Fully Adaptive Conformal Inference (FACI; @algo-faci) algorithm was developed by the authors of the original ACI algorithm in part to address the issue of how to choose the learning rate parameter $\gamma$. In this respect the goal of the algorithm is similar to that of AgACI, although it is achieved slightly differently. FACI also aggregates predictions from multiple copies of ACI run with different learning rates, but differs in that it directly aggregates the estimated radii emitted from each algorithm based on their pinball loss <span class="co">[</span><span class="ot">@gibbs2022faci</span><span class="co">]</span> using an exponential reweighting scheme <span class="co">[</span><span class="ot">@gradu2022adaptive</span><span class="co">]</span>. As opposed to AgACI, this construction allows for more straightforward development of theoretical guarantees on the algorithm's performance, because the upper and lower bounds of the intervals are not aggregated separately.</span>
<span id="cb1-396"><a href="#cb1-396" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-397"><a href="#cb1-397" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-398"><a href="#cb1-398" aria-hidden="true" tabindex="-1"></a><span class="fu">### Theoretical Guarantees</span></span>
<span id="cb1-399"><a href="#cb1-399" aria-hidden="true" tabindex="-1"></a>FACI was originally proposed with the choice of the quantile interval constructor. FACI has the following strongly-adaptive regret bound <span class="co">[</span><span class="ot">@bhatnagar2023saocp</span><span class="co">]</span>: for all $\gamma &gt; 0$ and subperiod lengths $m$,</span>
<span id="cb1-400"><a href="#cb1-400" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-401"><a href="#cb1-401" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-402"><a href="#cb1-402" aria-hidden="true" tabindex="-1"></a>  \mathrm{SAReg}(T, m) \leq \widetilde{\mathcal{O}}(D^2 / \gamma + \gamma m).</span>
<span id="cb1-403"><a href="#cb1-403" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-404"><a href="#cb1-404" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-405"><a href="#cb1-405" aria-hidden="true" tabindex="-1"></a>If $m$ is fixed a-priori, then choosing $\gamma = D/\sqrt{m}$ yields a strongly adaptive regret bound of order $\widetilde{\mathcal{O}}(D \sqrt{m})$ (for a single choice of $m$). Practically, this result implies that, if we know in advance the time length for which we would like to control the regret, it is possible to choose an optimal tuning parameter value. However, we cannot control the regret simultaneously for all possible time lengths.</span>
<span id="cb1-406"><a href="#cb1-406" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-407"><a href="#cb1-407" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-408"><a href="#cb1-408" aria-hidden="true" tabindex="-1"></a>To establish a bound on the coverage error, the authors investigated a slightly modified version of FACI in which $\theta_t$ is chosen randomly from the candidate $\theta_{t_k}$ with weights given by $p_{t,k}$, instead of taking a weighted average. This is a common trick used in the literature as it facilitates theoretical analysis. In practice, the authors comment that this randomized version of FACI and the deterministic version lead to very similar results. The coverage error result also assumes that the hyperparameters can change over time: that is, we have $t$-specific $\eta_{t}$ and $\sigma_t$, rather than fixed $\eta$ and $\sigma$. The coverage error then has the following bound <span class="co">[</span><span class="ot">@gibbs2022faci</span><span class="co">]</span>, where $\gamma_{\min}$ and $\gamma_{\max}$ are the smallest and largest learning rates in the grid, respectively:</span>
<span id="cb1-409"><a href="#cb1-409" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-410"><a href="#cb1-410" aria-hidden="true" tabindex="-1"></a>|\mathrm{CovErr}(T)| \leq \frac{1 + 2\gamma_{\max}}{T \gamma_{\min}} + \frac{(1 + 2\gamma_{\max})^2}{\gamma_{\min}} \exp(\eta_t(1 + 2\gamma_{\max})) \frac{1}{T}\sum_{t=1}^T \eta_t + 2 \frac{1+\gamma_{\max}}{\gamma_{\min}} \frac{1}{T} \sum_{t=1}^T \sigma_t.</span>
<span id="cb1-411"><a href="#cb1-411" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-412"><a href="#cb1-412" aria-hidden="true" tabindex="-1"></a>Thus, if $\eta_t$ and $\sigma_t$ both converge to zero as $t \to \infty$, then the coverage error will also converge to zero. In addition, under mild distributional assumptions the authors provide a type of short-term coverage error bound for arbitrary time spans, for which we refer to <span class="co">[</span><span class="ot">@gibbs2022faci</span><span class="co">]</span>. </span>
<span id="cb1-413"><a href="#cb1-413" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-414"><a href="#cb1-414" aria-hidden="true" tabindex="-1"></a>We note one additional result established by @gibbs2022faci on a slightly different regret bound in terms of the pinball loss, as it informs the choice of tuning parameters. Let $\gamma_{\mathrm{max}} = \max_{1 \leq k \leq K} \gamma_k$ be the largest learning rate in the grid and assume that $\gamma_1 &lt; \gamma_2 &lt; \cdots &lt; \gamma_K$ with $\gamma_{k+1}/\gamma \leq 2$ for all $1 \leq k &lt; K$. Then, for any interval $I = <span class="co">[</span><span class="ot">r, s</span><span class="co">]</span> \subseteq \llbracket T \rrbracket$ and any sequence $\theta_r^*, \dots, \theta_s^*$, under the assumption that $\gamma_k \geq \sqrt{1 + 1 / |I|}$,</span>
<span id="cb1-415"><a href="#cb1-415" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-416"><a href="#cb1-416" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-417"><a href="#cb1-417" aria-hidden="true" tabindex="-1"></a>  \frac{1}{|I|} \sum_{t=r}^s \mathbb{E}<span class="co">[</span><span class="ot">L^\alpha(\theta_t, r_t)</span><span class="co">]</span> - \frac{1}{|I|} \sum_{t=r}^s L^\alpha(\theta_t, \theta_t^*) \leq&amp; \frac{\log(k / \sigma) + 2\sigma|I|}{\eta |I|} + \frac{\eta}{|I|} \sum_{t=r}^s \mathbb{E}<span class="co">[</span><span class="ot">L^\alpha(\theta_t, r_t)^2</span><span class="co">]</span> <span class="sc">\\</span></span>
<span id="cb1-418"><a href="#cb1-418" aria-hidden="true" tabindex="-1"></a>  &amp;+ 2\sqrt{3}(1 + \gamma_{\mathrm{max}})^2 \max\left<span class="sc">\{</span> \sqrt{\frac{\sum_{t=r+1}^s |\theta_t^* - \theta_{t-1}^*| + 1}{|I|}}, \gamma_1 \right<span class="sc">\}</span>,</span>
<span id="cb1-419"><a href="#cb1-419" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-420"><a href="#cb1-420" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-421"><a href="#cb1-421" aria-hidden="true" tabindex="-1"></a>where the expectation is over the randomness in the randomized version of the algorithm.  Here the time interval $I$ (with length $|I|$) is comparable to the time period length $m$ for the strongly adaptive regret. The parameter $|I|$, the time interval of interest for which we would like to control, can be chosen arbitrarily. </span>
<span id="cb1-422"><a href="#cb1-422" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-423"><a href="#cb1-423" aria-hidden="true" tabindex="-1"></a><span class="fu">### Tuning parameters</span></span>
<span id="cb1-424"><a href="#cb1-424" aria-hidden="true" tabindex="-1"></a>The recommended settings for the tuning parameters depend on choosing a time interval length $|I|$ for which we would like to control the pinball loss. The choice of $|I|$ can be chosen arbitrarily.</span>
<span id="cb1-425"><a href="#cb1-425" aria-hidden="true" tabindex="-1"></a>For the tuning parameter $\sigma$, the authors suggest the optimal choice $\sigma = 1 / (2 |I|)$. Choosing $\eta$ is more difficult. The authors suggest the following choice for $\eta$, which they show is optimal if there is in fact no distribution shift:</span>
<span id="cb1-426"><a href="#cb1-426" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-427"><a href="#cb1-427" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-428"><a href="#cb1-428" aria-hidden="true" tabindex="-1"></a>  \eta = \sqrt{\frac{3}{|I|}} \sqrt{\frac{\log(K \cdot |I|) + 2}{(\alpha)^2 (1 - \alpha)^3 + (1-\alpha)^2 \alpha^3 }}</span>
<span id="cb1-429"><a href="#cb1-429" aria-hidden="true" tabindex="-1"></a>\end{aligned}.</span>
<span id="cb1-430"><a href="#cb1-430" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-431"><a href="#cb1-431" aria-hidden="true" tabindex="-1"></a>Note that this choice is optimal only for the quantile interval constructor, for which $\theta_t$ is a quantile of previous nonconformity scores. As an alternative, the authors point out that $\eta$ can be learned in an online fashion using the update rule</span>
<span id="cb1-432"><a href="#cb1-432" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-433"><a href="#cb1-433" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-434"><a href="#cb1-434" aria-hidden="true" tabindex="-1"></a>  \eta_t := \sqrt{\frac{\log(|I| K) + 2}{\sum_{s=t-|I|}^{t-1} L^\alpha(\theta_s, r_s)}}.</span>
<span id="cb1-435"><a href="#cb1-435" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-436"><a href="#cb1-436" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-437"><a href="#cb1-437" aria-hidden="true" tabindex="-1"></a>Both ways of choosing $\eta$ led to very similar results in the original author's empirical studies. In our proposed <span class="in">`AdaptiveConformal`</span> package, the first approach is used when the quantile interval construction function is chosen, and the latter approach for the linear interval construction function.</span>
<span id="cb1-438"><a href="#cb1-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-439"><a href="#cb1-439" aria-hidden="true" tabindex="-1"></a>@fig-faci-example illustrates FACI with the quantile interval construction function and with the learning rate grid $\gamma \in <span class="sc">\{</span> 0.001, 0.002, 0.004, 0.008, 0.016, 0.032, 0.064, 0.128 <span class="sc">\}</span>$.</span>
<span id="cb1-440"><a href="#cb1-440" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-441"><a href="#cb1-441" aria-hidden="true" tabindex="-1"></a><span class="in">```{r faci_example_plot, echo = FALSE}</span></span>
<span id="cb1-442"><a href="#cb1-442" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-faci-example</span></span>
<span id="cb1-443"><a href="#cb1-443" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 4.5</span></span>
<span id="cb1-444"><a href="#cb1-444" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Example 80% prediction intervals generated by the FACI algorithm with starting values $\\theta_1 = 0.8$. Blue and red points are observations that fell inside and outside the prediction intervals, respectively."</span></span>
<span id="cb1-445"><a href="#cb1-445" aria-hidden="true" tabindex="-1"></a>gamma_grid <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.001</span>, <span class="fl">0.002</span>, <span class="fl">0.004</span>, <span class="fl">0.008</span>, <span class="fl">0.016</span>, <span class="fl">0.032</span>, <span class="fl">0.064</span>, <span class="fl">0.128</span>)</span>
<span id="cb1-446"><a href="#cb1-446" aria-hidden="true" tabindex="-1"></a>result <span class="ot">&lt;-</span> <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"FACI"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">gamma_grid =</span> gamma_grid, <span class="at">interval_constructor =</span> <span class="st">"conformal"</span>))</span>
<span id="cb1-447"><a href="#cb1-447" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-448"><a href="#cb1-448" aria-hidden="true" tabindex="-1"></a>coverage    <span class="ot">&lt;-</span> <span class="fu">format_coverage</span>(<span class="fu">extract_metric</span>(<span class="fu">list</span>(result), <span class="st">"coverage"</span>))</span>
<span id="cb1-449"><a href="#cb1-449" aria-hidden="true" tabindex="-1"></a>path_length <span class="ot">&lt;-</span> <span class="fu">format_path_length</span>(<span class="fu">extract_metric</span>(<span class="fu">list</span>(result), <span class="st">"path_length"</span>))</span>
<span id="cb1-450"><a href="#cb1-450" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-451"><a href="#cb1-451" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(result, <span class="at">ylim =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.9</span>, <span class="fl">0.8</span>), <span class="at">legend =</span> <span class="cn">FALSE</span>)</span>
<span id="cb1-452"><a href="#cb1-452" aria-hidden="true" tabindex="-1"></a><span class="fu">text</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">0.75</span>, <span class="at">labels =</span> <span class="fu">bquote</span>(EmpCov <span class="sc">==</span> .(coverage[[<span class="dv">1</span>]]) ), <span class="at">pos =</span> <span class="dv">4</span>)</span>
<span id="cb1-453"><a href="#cb1-453" aria-hidden="true" tabindex="-1"></a><span class="fu">text</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">0.9</span>, <span class="at">labels =</span> <span class="fu">bquote</span>(PathLength <span class="sc">==</span> .(path_length[[<span class="dv">1</span>]])), <span class="at">pos =</span> <span class="dv">4</span>)</span>
<span id="cb1-454"><a href="#cb1-454" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-455"><a href="#cb1-455" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-456"><a href="#cb1-456" aria-hidden="true" tabindex="-1"></a><span class="fu">## Scale-Free Online Gradient Descent (SF-OGD)</span></span>
<span id="cb1-457"><a href="#cb1-457" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb1-458"><a href="#cb1-458" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: algo-sfogd</span></span>
<span id="cb1-459"><a href="#cb1-459" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb1-460"><a href="#cb1-460" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb1-461"><a href="#cb1-461" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb1-462"><a href="#cb1-462" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb1-463"><a href="#cb1-463" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb1-464"><a href="#cb1-464" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb1-465"><a href="#cb1-465" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb1-466"><a href="#cb1-466" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-467"><a href="#cb1-467" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb1-468"><a href="#cb1-468" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Scale-Free Online Gradient Descent}</span></span>
<span id="cb1-469"><a href="#cb1-469" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb1-470"><a href="#cb1-470" aria-hidden="true" tabindex="-1"></a><span class="in">\State \textbf{Input:} starting value $\theta_1$, learning rate $\gamma &gt; 0$.</span></span>
<span id="cb1-471"><a href="#cb1-471" aria-hidden="true" tabindex="-1"></a><span class="in">\For{$t = 1, 2, \dots, T$}</span></span>
<span id="cb1-472"><a href="#cb1-472" aria-hidden="true" tabindex="-1"></a><span class="in">  \State \textbf{Output:} prediction interval $\widehat{C}_t(\theta_t)$. </span></span>
<span id="cb1-473"><a href="#cb1-473" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Observe $y_t$ and compute $r_t$. </span></span>
<span id="cb1-474"><a href="#cb1-474" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Update $\theta_{t+1} = \theta_t - \gamma \frac{\nabla L^\alpha(\theta_t, r_t)}{\sqrt{\sum_{i=1}^t} \| \nabla L^\alpha(\theta_i, r_i) \|_2^2}$.</span></span>
<span id="cb1-475"><a href="#cb1-475" aria-hidden="true" tabindex="-1"></a><span class="in">\EndFor</span></span>
<span id="cb1-476"><a href="#cb1-476" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb1-477"><a href="#cb1-477" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb1-478"><a href="#cb1-478" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-479"><a href="#cb1-479" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-480"><a href="#cb1-480" aria-hidden="true" tabindex="-1"></a>Scale-Free Online Gradient Descent (SF-OGD; @algo-sfogd) is a general algorithm for online learning proposed by @orabona2018sfogd. The algorithm updates $\theta_t$ with a gradient descent step where the learning rate adapts to the scale of the previously observed gradients. SF-OGD was first used in the context of ACI as a sub-algorithm for SAOCP (described in the next section). However, it was found to have good performance by itself <span class="co">[</span><span class="ot">@bhatnagar2023saocp</span><span class="co">]</span> in real-world tasks, so we have made it available in the package as a stand-alone algorithm. </span>
<span id="cb1-481"><a href="#cb1-481" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-482"><a href="#cb1-482" aria-hidden="true" tabindex="-1"></a><span class="fu">### Theoretical Guarantees</span></span>
<span id="cb1-483"><a href="#cb1-483" aria-hidden="true" tabindex="-1"></a>The SF-OGD algorithm with linear interval constructor has the following regret bound, which is called an _anytime regret bound_ because it holds for all $t \in \llbracket T \rrbracket$ <span class="co">[</span><span class="ot">@bhatnagar2023saocp</span><span class="co">]</span>. For any $\gamma &gt; 0$, </span>
<span id="cb1-484"><a href="#cb1-484" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-485"><a href="#cb1-485" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-486"><a href="#cb1-486" aria-hidden="true" tabindex="-1"></a>  \mathrm{Reg}(t) \leq \mathcal{O}(D \sqrt{t}) \text{ for all } t \in \llbracket T \rrbracket.</span>
<span id="cb1-487"><a href="#cb1-487" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-488"><a href="#cb1-488" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-489"><a href="#cb1-489" aria-hidden="true" tabindex="-1"></a>A bound for the coverage error has also been established <span class="co">[</span><span class="ot">@bhatnagar2023saocp</span><span class="co">]</span>. For any learning rate $\gamma = \Theta(D)$ (where $\gamma = D / \sqrt{3}$ is optimal) and any starting value $\theta_1 \in <span class="co">[</span><span class="ot">0, D</span><span class="co">]</span>$, then it holds that for any $T &gt; 1$,</span>
<span id="cb1-490"><a href="#cb1-490" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-491"><a href="#cb1-491" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-492"><a href="#cb1-492" aria-hidden="true" tabindex="-1"></a>  |\mathrm{CovErr}(T)| \leq \mathcal{O}\left( (1 - \alpha)^{-2} T^{-1/4} \log T \right).</span>
<span id="cb1-493"><a href="#cb1-493" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-494"><a href="#cb1-494" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-495"><a href="#cb1-495" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-496"><a href="#cb1-496" aria-hidden="true" tabindex="-1"></a><span class="fu">### Tuning parameters</span></span>
<span id="cb1-497"><a href="#cb1-497" aria-hidden="true" tabindex="-1"></a><span class="co">[</span><span class="ot">@fig-sf-ogd</span><span class="co">]</span> compares results for several choices of $\gamma$ to illustrate its effect. The optimal choice of learning rate is $\gamma = D / \sqrt{3}$, where $D$ is the maximum possible radius. When $D$ is not known, it can be estimated by using an initial subset of the time series as a calibration set and estimating $D$ as the maximum of the absolute residuals of the observations and the predictions <span class="co">[</span><span class="ot">@bhatnagar2023saocp</span><span class="co">]</span>. @fig-sf-ogd illustrates SF-OGD for several values of $\gamma$.</span>
<span id="cb1-498"><a href="#cb1-498" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-499"><a href="#cb1-499" aria-hidden="true" tabindex="-1"></a><span class="in">```{r sfogd_example_plot, echo = FALSE}</span></span>
<span id="cb1-500"><a href="#cb1-500" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-sf-ogd</span></span>
<span id="cb1-501"><a href="#cb1-501" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 4.5</span></span>
<span id="cb1-502"><a href="#cb1-502" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Example 80% prediction intervals generated by the SF-OGD algorithm with different values of the maximum radius tuning parameter $D$. Blue and red points are observations that fell inside and outside the prediction intervals, respectively."</span></span>
<span id="cb1-503"><a href="#cb1-503" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> <span class="fl">0.8</span></span>
<span id="cb1-504"><a href="#cb1-504" aria-hidden="true" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb1-505"><a href="#cb1-505" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"SF-OGD"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">gamma =</span> <span class="fl">0.01</span>)),</span>
<span id="cb1-506"><a href="#cb1-506" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"SF-OGD"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">gamma =</span> <span class="fl">0.1</span>)),</span>
<span id="cb1-507"><a href="#cb1-507" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"SF-OGD"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">gamma =</span> <span class="fl">0.25</span>)),</span>
<span id="cb1-508"><a href="#cb1-508" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"SF-OGD"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">gamma =</span> <span class="fl">0.5</span>))</span>
<span id="cb1-509"><a href="#cb1-509" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-510"><a href="#cb1-510" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-511"><a href="#cb1-511" aria-hidden="true" tabindex="-1"></a>coverage    <span class="ot">&lt;-</span> <span class="fu">format_coverage</span>(<span class="fu">extract_metric</span>(results, <span class="st">"coverage"</span>))</span>
<span id="cb1-512"><a href="#cb1-512" aria-hidden="true" tabindex="-1"></a>path_length <span class="ot">&lt;-</span> <span class="fu">format_path_length</span>(<span class="fu">extract_metric</span>(results, <span class="st">"path_length"</span>))</span>
<span id="cb1-513"><a href="#cb1-513" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-514"><a href="#cb1-514" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>))</span>
<span id="cb1-515"><a href="#cb1-515" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>) {</span>
<span id="cb1-516"><a href="#cb1-516" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot</span>(results[[i]], <span class="at">legend =</span> <span class="cn">FALSE</span>, <span class="at">predictions =</span> <span class="cn">FALSE</span>, <span class="at">cex =</span> <span class="fl">0.5</span>, <span class="at">main =</span> <span class="fu">bquote</span>(gamma<span class="sc">==</span>.(results[[i]]<span class="sc">$</span>parameters<span class="sc">$</span>gamma)), <span class="at">ylim =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.9</span>, <span class="fl">0.8</span>))</span>
<span id="cb1-517"><a href="#cb1-517" aria-hidden="true" tabindex="-1"></a>  <span class="fu">text</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">0.75</span>, <span class="at">labels =</span> <span class="fu">bquote</span>(EmpCov <span class="sc">==</span> .(coverage[[i]]) ), <span class="at">pos =</span> <span class="dv">4</span>)</span>
<span id="cb1-518"><a href="#cb1-518" aria-hidden="true" tabindex="-1"></a>  <span class="fu">text</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">0.9</span>, <span class="at">labels =</span> <span class="fu">bquote</span>(PathLength <span class="sc">==</span> .(path_length[[i]])), <span class="at">pos =</span> <span class="dv">4</span>)</span>
<span id="cb1-519"><a href="#cb1-519" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-520"><a href="#cb1-520" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="fl">5.1</span>, <span class="fl">4.1</span>, <span class="fl">4.1</span>, <span class="fl">2.1</span>))</span>
<span id="cb1-521"><a href="#cb1-521" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-522"><a href="#cb1-522" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-523"><a href="#cb1-523" aria-hidden="true" tabindex="-1"></a><span class="fu">## Strongly Adaptive Online Conformal Prediction (SAOCP)</span></span>
<span id="cb1-524"><a href="#cb1-524" aria-hidden="true" tabindex="-1"></a><span class="in">```pseudocode</span></span>
<span id="cb1-525"><a href="#cb1-525" aria-hidden="true" tabindex="-1"></a><span class="in">#| label: algo-saocp</span></span>
<span id="cb1-526"><a href="#cb1-526" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-indent-size: "1.2em"</span></span>
<span id="cb1-527"><a href="#cb1-527" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-comment-delimiter: "//"</span></span>
<span id="cb1-528"><a href="#cb1-528" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number: true</span></span>
<span id="cb1-529"><a href="#cb1-529" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-line-number-punc: ":"</span></span>
<span id="cb1-530"><a href="#cb1-530" aria-hidden="true" tabindex="-1"></a><span class="in">#| html-no-end: false</span></span>
<span id="cb1-531"><a href="#cb1-531" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-placement: "htb!"</span></span>
<span id="cb1-532"><a href="#cb1-532" aria-hidden="true" tabindex="-1"></a><span class="in">#| pdf-line-number: true</span></span>
<span id="cb1-533"><a href="#cb1-533" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-534"><a href="#cb1-534" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithm}</span></span>
<span id="cb1-535"><a href="#cb1-535" aria-hidden="true" tabindex="-1"></a><span class="in">\caption{Strongly Adaptive Online Conformal Prediction}</span></span>
<span id="cb1-536"><a href="#cb1-536" aria-hidden="true" tabindex="-1"></a><span class="in">\begin{algorithmic}</span></span>
<span id="cb1-537"><a href="#cb1-537" aria-hidden="true" tabindex="-1"></a><span class="in">\State \textbf{Input:} initial value $\theta_0$, learning rate $\gamma &gt; 0$.</span></span>
<span id="cb1-538"><a href="#cb1-538" aria-hidden="true" tabindex="-1"></a><span class="in">\For{$t = 1, 2, \dots, T$}</span></span>
<span id="cb1-539"><a href="#cb1-539" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Initialize expert $\mathcal{A}_t = \texttt{SF-OGD}(\alpha \leftarrow \alpha, \gamma \leftarrow \gamma, \theta_1 \leftarrow \theta_{t-1})$, set weight $w_t^t = 0$.</span></span>
<span id="cb1-540"><a href="#cb1-540" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Compute active set $\mathrm{Active}(t) = \{ i \in \llbracket T \rrbracket : t - L(i) &lt; i \leq t \}$ (see below for definition of $L(t)$).</span></span>
<span id="cb1-541"><a href="#cb1-541" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Compute prior probability $\pi_i \propto i^{-2} (1 + \lfloor \log_2 i \rfloor )^{-1} \mathbb{I}[i \in \mathrm{Active}(t)]$.</span></span>
<span id="cb1-542"><a href="#cb1-542" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Compute un-normalized probability $\hat{p}_i = \pi_i [w_{t,i}]_+$ for all $i \in \llbracket t \rrbracket$.</span></span>
<span id="cb1-543"><a href="#cb1-543" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Normalize $p = \hat{p} / \| \hat{p} \|_1 \in \Delta^t$ if $\| \hat{p} \|_1 &gt; 0$, else $p = \pi$.</span></span>
<span id="cb1-544"><a href="#cb1-544" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Set $\theta_t = \sum_{i \in \mathrm{Active}(t)} p_i \theta_t^i$ (for $t \geq 2$), and $\theta_t = 0$ for $t = 1$.</span></span>
<span id="cb1-545"><a href="#cb1-545" aria-hidden="true" tabindex="-1"></a><span class="in">  \State \textbf{Output:} prediction set $\widehat{C}_t(\theta_t)$.</span></span>
<span id="cb1-546"><a href="#cb1-546" aria-hidden="true" tabindex="-1"></a><span class="in">  \State Observe $y_t$ and compute $r_t$. </span></span>
<span id="cb1-547"><a href="#cb1-547" aria-hidden="true" tabindex="-1"></a><span class="in">  \For{$i \in \mathrm{Active}(t)$}</span></span>
<span id="cb1-548"><a href="#cb1-548" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Update expert $\mathcal{A}_t$ with $y_t$ and obtain $\theta_{t+1}^i$.</span></span>
<span id="cb1-549"><a href="#cb1-549" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Compute $g_t^i = \begin{cases}</span></span>
<span id="cb1-550"><a href="#cb1-550" aria-hidden="true" tabindex="-1"></a><span class="in">      \frac{1}{D}\left(L^\alpha(\theta_t, r_t) - L^\alpha(\theta_t^i, r_t)\right) &amp; w_t^i &gt; 0 \\</span></span>
<span id="cb1-551"><a href="#cb1-551" aria-hidden="true" tabindex="-1"></a><span class="in">      \frac{1}{D}\left[L^\alpha(\theta_t, r_t) - L^\alpha(\theta_t^i, r_t))\right]_+ &amp; w_t^i \leq 0 \\</span></span>
<span id="cb1-552"><a href="#cb1-552" aria-hidden="true" tabindex="-1"></a><span class="in">    \end{cases}$.</span></span>
<span id="cb1-553"><a href="#cb1-553" aria-hidden="true" tabindex="-1"></a><span class="in">    \State Update expert weight $w_{t+1}^i = \frac{1}{t - i + 1}\left( \sum_{j=i}^t g_j^i \right) \left(1 + \sum_{j=i}^t w_j^i g_j^i \right)$.</span></span>
<span id="cb1-554"><a href="#cb1-554" aria-hidden="true" tabindex="-1"></a><span class="in">  \EndFor</span></span>
<span id="cb1-555"><a href="#cb1-555" aria-hidden="true" tabindex="-1"></a><span class="in">\EndFor</span></span>
<span id="cb1-556"><a href="#cb1-556" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithmic}</span></span>
<span id="cb1-557"><a href="#cb1-557" aria-hidden="true" tabindex="-1"></a><span class="in">\end{algorithm}</span></span>
<span id="cb1-558"><a href="#cb1-558" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-559"><a href="#cb1-559" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-560"><a href="#cb1-560" aria-hidden="true" tabindex="-1"></a>The Strongly Adaptive Online Conformal Prediction (SAOCP; @algo-saocp) algorithm was proposed as an improvement over the extant ACI algorithms in that it features stronger theoretical guarantees. SAOCP works similarly to AgACI and FACI in that it maintains a library of candidate online learning algorithms that generate prediction intervals which are then aggregated using a meta-algorithm <span class="co">[</span><span class="ot">@bhatnagar2023saocp</span><span class="co">]</span>. The candidate algorithm was chosen to be SF-OGD, although any algorithm that features anytime regret guarantees can be chosen. As opposed to AgACI and FACI, in which each candidate has a different learning rate but is always able to contribute to the final prediction intervals, here each candidate has the same learning rate but only has positive weight over a specific interval of time. New candidate algorithms are continually being spawned in order that, if the distribution shifts rapidly, the newer candidates will be able to react quickly and receive positive weight. Specifically, at each time point, a new expert is instantiated which is active over a finite ``lifetime". Define the _lifetime_ of an expert instantiated at time $t$ as </span>
<span id="cb1-561"><a href="#cb1-561" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-562"><a href="#cb1-562" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-563"><a href="#cb1-563" aria-hidden="true" tabindex="-1"></a>  L(t) := g \cdot \max_{n \in \mathbb{Z}} <span class="sc">\{</span> 2^n t \equiv 0 \mod 2^n <span class="sc">\}</span>,</span>
<span id="cb1-564"><a href="#cb1-564" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-565"><a href="#cb1-565" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-566"><a href="#cb1-566" aria-hidden="true" tabindex="-1"></a>where $g \in \mathbb{Z}^*$ is a _lifetime multiplier_ parameter. The active experts are weighted according to their empirical performance with respect to the pinball loss function. The authors show that this construction results in intervals that have strong regret guarantees.</span>
<span id="cb1-567"><a href="#cb1-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-568"><a href="#cb1-568" aria-hidden="true" tabindex="-1"></a><span class="fu">### Theoretical Guarantees</span></span>
<span id="cb1-569"><a href="#cb1-569" aria-hidden="true" tabindex="-1"></a>The theoretical results were established for SAOCP using the linear interval constructor. The following bound for the strongly adaptive regret holds for all subperiod lengths $m \in \llbracket T \rrbracket$ <span class="co">[</span><span class="ot">@bhatnagar2023saocp</span><span class="co">]</span>:</span>
<span id="cb1-570"><a href="#cb1-570" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-571"><a href="#cb1-571" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-572"><a href="#cb1-572" aria-hidden="true" tabindex="-1"></a>  \mathrm{SAReg}(T, m) \leq 15 D \sqrt{m(\log T + 1)} \leq \tilde{\mathcal{O}}(D \sqrt m).</span>
<span id="cb1-573"><a href="#cb1-573" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-574"><a href="#cb1-574" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-575"><a href="#cb1-575" aria-hidden="true" tabindex="-1"></a>It should be emphasized that this regret bounds holds simultaneously across all $m$, as opposed to FACI, where a similar bound holds only for a single $m$. A bound on the coverage error of SAOCP has also been established  as:</span>
<span id="cb1-576"><a href="#cb1-576" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-577"><a href="#cb1-577" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-578"><a href="#cb1-578" aria-hidden="true" tabindex="-1"></a>  |\mathrm{CovErr}(T)| \leq \mathcal{O}\left(\inf_\beta(T^{1/2 - \beta} + T^{\beta - 1} S_\beta(T))\right).</span>
<span id="cb1-579"><a href="#cb1-579" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-580"><a href="#cb1-580" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-581"><a href="#cb1-581" aria-hidden="true" tabindex="-1"></a>where $S_{\beta}(T)$ is a technical measure of the smoothness of the cumulative gradients and expert weights for each of the candidate experts <span class="co">[</span><span class="ot">@bhatnagar2023saocp</span><span class="co">]</span>.</span>
<span id="cb1-582"><a href="#cb1-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-583"><a href="#cb1-583" aria-hidden="true" tabindex="-1"></a><span class="fu">### Tuning Parameters</span></span>
<span id="cb1-584"><a href="#cb1-584" aria-hidden="true" tabindex="-1"></a>The main tuning parameter for SAOCP is the learning rate $\gamma$ of the SF-OGD sub-algorithms, which we saw in the previous section has for optimal choice $\gamma = D / \sqrt{3}$. Values for $D$ that are too low lead to intervals that adapt slowly, and values that are too large lead to jagged intervals. In their experiments, the authors select a value for $D$ by picking the maximum residual from a calibration set. The second tuning parameter is the lifetime multiplier $g$ which controls the lifetime of each of the experts. We follow the original paper in setting $g = 8$. @fig-saocp illustrates the SAOCP algorithm for choices of $D \in <span class="sc">\{</span>0.01, 0.1, 0.25, 0.5 <span class="sc">\}</span>$. </span>
<span id="cb1-585"><a href="#cb1-585" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-586"><a href="#cb1-586" aria-hidden="true" tabindex="-1"></a><span class="in">```{r saocp_example_plot, echo = FALSE}</span></span>
<span id="cb1-587"><a href="#cb1-587" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-saocp</span></span>
<span id="cb1-588"><a href="#cb1-588" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 4.5</span></span>
<span id="cb1-589"><a href="#cb1-589" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Example 80% prediction intervals generated by the SAOCP algorithm with different values of the maximum radius parameter $D$. Blue and red points are observations that fell inside and outside the prediction intervals, respectively."</span></span>
<span id="cb1-590"><a href="#cb1-590" aria-hidden="true" tabindex="-1"></a>alpha <span class="ot">&lt;-</span> <span class="fl">0.8</span></span>
<span id="cb1-591"><a href="#cb1-591" aria-hidden="true" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb1-592"><a href="#cb1-592" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"SAOCP"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="fl">0.01</span>)),</span>
<span id="cb1-593"><a href="#cb1-593" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"SAOCP"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="fl">0.1</span>)),</span>
<span id="cb1-594"><a href="#cb1-594" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"SAOCP"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="fl">0.25</span>)),</span>
<span id="cb1-595"><a href="#cb1-595" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(y, muhat, <span class="at">alpha =</span> alpha, <span class="at">method =</span> <span class="st">"SAOCP"</span>, <span class="at">parameters =</span> <span class="fu">list</span>(<span class="at">D =</span> <span class="fl">0.5</span>))</span>
<span id="cb1-596"><a href="#cb1-596" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-597"><a href="#cb1-597" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-598"><a href="#cb1-598" aria-hidden="true" tabindex="-1"></a>coverage    <span class="ot">&lt;-</span> <span class="fu">format_coverage</span>(<span class="fu">extract_metric</span>(results, <span class="st">"coverage"</span>))</span>
<span id="cb1-599"><a href="#cb1-599" aria-hidden="true" tabindex="-1"></a>path_length <span class="ot">&lt;-</span> <span class="fu">format_path_length</span>(<span class="fu">extract_metric</span>(results, <span class="st">"path_length"</span>))</span>
<span id="cb1-600"><a href="#cb1-600" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-601"><a href="#cb1-601" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>))</span>
<span id="cb1-602"><a href="#cb1-602" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>) {</span>
<span id="cb1-603"><a href="#cb1-603" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot</span>(results[[i]], <span class="at">legend =</span> <span class="cn">FALSE</span>, <span class="at">predictions =</span> <span class="cn">FALSE</span>, <span class="at">cex =</span> <span class="fl">0.5</span>, <span class="at">main =</span> <span class="fu">bquote</span>(D<span class="sc">==</span>.(results[[i]]<span class="sc">$</span>parameters<span class="sc">$</span>D)), <span class="at">ylim =</span> <span class="fu">c</span>(<span class="sc">-</span><span class="fl">0.9</span>, <span class="fl">0.8</span>))</span>
<span id="cb1-604"><a href="#cb1-604" aria-hidden="true" tabindex="-1"></a>  <span class="fu">text</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">0.75</span>, <span class="at">labels =</span> <span class="fu">bquote</span>(EmpCov <span class="sc">==</span> .(coverage[[i]])), <span class="at">pos =</span> <span class="dv">4</span>)</span>
<span id="cb1-605"><a href="#cb1-605" aria-hidden="true" tabindex="-1"></a>  <span class="fu">text</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">0.9</span>, <span class="at">labels =</span> <span class="fu">bquote</span>(PathLength <span class="sc">==</span> .(path_length[[i]])), <span class="at">pos =</span> <span class="dv">4</span>)</span>
<span id="cb1-606"><a href="#cb1-606" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-607"><a href="#cb1-607" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="fl">5.1</span>, <span class="fl">4.1</span>, <span class="fl">4.1</span>, <span class="fl">2.1</span>))</span>
<span id="cb1-608"><a href="#cb1-608" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-609"><a href="#cb1-609" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-610"><a href="#cb1-610" aria-hidden="true" tabindex="-1"></a><span class="fu"># Simulation Studies {#sec-simulations}</span></span>
<span id="cb1-611"><a href="#cb1-611" aria-hidden="true" tabindex="-1"></a>We present two empirical studies in order to compare the performance of the AgACI, FACI, SF-OGD, and SAOCP algorithms applied to simple simulated datasets. The original ACI algorithm was not included as it is not clear how to set the tuning rate $\gamma$, which can have a large effect on the resulting intervals. For both simulations we set the targeted empirical coverage to $\alpha = 0.8$, $\alpha = 0.9$, and $\alpha = 0.95$. For each algorithm, we chose the interval constructor that was used in its original presentation (see @tbl-aci). </span>
<span id="cb1-612"><a href="#cb1-612" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-613"><a href="#cb1-613" aria-hidden="true" tabindex="-1"></a><span class="fu">## Time series with ARMA errors</span></span>
<span id="cb1-614"><a href="#cb1-614" aria-hidden="true" tabindex="-1"></a>In this simulation we reproduce the setup described in @zaffran2022agaci (itself based on that of @friedman1983). The time series values $y_t$ for $t \in \llbracket T \rrbracket$ ($T = 600$) are simulated according to</span>
<span id="cb1-615"><a href="#cb1-615" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-616"><a href="#cb1-616" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-617"><a href="#cb1-617" aria-hidden="true" tabindex="-1"></a>  y_t = 10\sin(\pi X_{t,1}X_{t,2}) + 20(X_{t,3} - 0.5)^2 + 10X_{t,4} + 5 X_{t,5} + 0X_{t,6} + \epsilon_t,</span>
<span id="cb1-618"><a href="#cb1-618" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-619"><a href="#cb1-619" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-620"><a href="#cb1-620" aria-hidden="true" tabindex="-1"></a>where $X_{t,i}$, $i = 1, \dots, 6$, $t \in \llbracket T \rrbracket$ are independently uniformly distributed on $<span class="co">[</span><span class="ot">0, 1</span><span class="co">]</span>$ and the noise terms $\epsilon_t$ are generated according to an ARMA(1, 1) process:</span>
<span id="cb1-621"><a href="#cb1-621" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-622"><a href="#cb1-622" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-623"><a href="#cb1-623" aria-hidden="true" tabindex="-1"></a>  \epsilon_t &amp;= \psi \epsilon_{t-1} + \xi_t + \theta \xi_{t-1}, <span class="sc">\\</span></span>
<span id="cb1-624"><a href="#cb1-624" aria-hidden="true" tabindex="-1"></a>  \xi_t &amp;\sim N(0, \sigma^2).</span>
<span id="cb1-625"><a href="#cb1-625" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-626"><a href="#cb1-626" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-627"><a href="#cb1-627" aria-hidden="true" tabindex="-1"></a>We set $\psi$ and $\theta$ jointly to each value in $<span class="sc">\{</span> 0.1, 0.8, 0.9, 0.95, 0.99 <span class="sc">\}</span>$ to simulate time series with increasing temporal dependence. The innovation variance was set to $\sigma^2 = (1 - \psi^2) / (1 + 2\psi \xi + \xi^2)$ (to ensure that the process has constant variance). For each setting, 25 simulated datasets were generated.</span>
<span id="cb1-628"><a href="#cb1-628" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-629"><a href="#cb1-629" aria-hidden="true" tabindex="-1"></a>To provide point predictions for the ACI algorithms, at each time $t \geq 200$ a random forest model was fitted to the previously observed data using the <span class="in">`ranger`</span> <span class="in">`R`</span> package <span class="co">[</span><span class="ot">@wright2017ranger</span><span class="co">]</span>. The estimated model was then used to predict the subsequent time point. The maximum radius $D$ was estimated as the maximum residual observed between time points $t=200$ and $t=249$. The ACI models were then executed starting at time point $t = 250$. All metrics are based on time points $t \geq 300$ to allow time for the ACI methods to initialize. </span>
<span id="cb1-630"><a href="#cb1-630" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-631"><a href="#cb1-631" aria-hidden="true" tabindex="-1"></a><span class="in">```{r simulation_study_one, cache = TRUE}</span></span>
<span id="cb1-632"><a href="#cb1-632" aria-hidden="true" tabindex="-1"></a>simulate <span class="ot">&lt;-</span> <span class="cf">function</span>(seed, psi, xi, <span class="at">N =</span> <span class="fl">1e3</span>) {</span>
<span id="cb1-633"><a href="#cb1-633" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(seed)</span>
<span id="cb1-634"><a href="#cb1-634" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-635"><a href="#cb1-635" aria-hidden="true" tabindex="-1"></a>  s <span class="ot">&lt;-</span> <span class="dv">10</span></span>
<span id="cb1-636"><a href="#cb1-636" aria-hidden="true" tabindex="-1"></a>  innov_scale <span class="ot">&lt;-</span> <span class="fu">sqrt</span>(s <span class="sc">*</span> (<span class="dv">1</span> <span class="sc">-</span> psi<span class="sc">^</span><span class="dv">2</span>) <span class="sc">/</span> (<span class="dv">1</span> <span class="sc">+</span> <span class="dv">2</span> <span class="sc">*</span> psi <span class="sc">*</span> xi <span class="sc">+</span> xi<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb1-637"><a href="#cb1-637" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-638"><a href="#cb1-638" aria-hidden="true" tabindex="-1"></a>  X <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">runif</span>(<span class="dv">6</span> <span class="sc">*</span> N), <span class="at">ncol =</span> <span class="dv">6</span>, <span class="at">nrow =</span> N)</span>
<span id="cb1-639"><a href="#cb1-639" aria-hidden="true" tabindex="-1"></a>  <span class="fu">colnames</span>(X) <span class="ot">&lt;-</span> <span class="fu">paste0</span>(<span class="st">"X"</span>, <span class="dv">1</span><span class="sc">:</span><span class="dv">6</span>)</span>
<span id="cb1-640"><a href="#cb1-640" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-641"><a href="#cb1-641" aria-hidden="true" tabindex="-1"></a>  epsilon <span class="ot">&lt;-</span> <span class="fu">arima.sim</span>(<span class="at">n =</span> N, <span class="at">model =</span> <span class="fu">list</span>(<span class="at">ar =</span> psi, <span class="at">ma =</span> xi), <span class="at">sd =</span> innov_scale)</span>
<span id="cb1-642"><a href="#cb1-642" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-643"><a href="#cb1-643" aria-hidden="true" tabindex="-1"></a>  mu <span class="ot">&lt;-</span> <span class="dv">10</span> <span class="sc">*</span> <span class="fu">sin</span>(pi <span class="sc">*</span> X[,<span class="dv">1</span>] <span class="sc">*</span> X[,<span class="dv">2</span>]) <span class="sc">+</span> <span class="dv">20</span> <span class="sc">*</span> (X[,<span class="dv">3</span>] <span class="sc">-</span> <span class="fl">0.5</span>)<span class="sc">^</span><span class="dv">2</span> <span class="sc">+</span> <span class="dv">10</span> <span class="sc">*</span> X[,<span class="dv">4</span>] <span class="sc">+</span> <span class="dv">5</span> <span class="sc">*</span> X[,<span class="dv">5</span>]</span>
<span id="cb1-644"><a href="#cb1-644" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> mu <span class="sc">+</span> epsilon</span>
<span id="cb1-645"><a href="#cb1-645" aria-hidden="true" tabindex="-1"></a>  <span class="fu">as_tibble</span>(X) <span class="sc">%&gt;%</span> <span class="fu">mutate</span>(<span class="at">y =</span> y)</span>
<span id="cb1-646"><a href="#cb1-646" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-647"><a href="#cb1-647" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-648"><a href="#cb1-648" aria-hidden="true" tabindex="-1"></a>estimate_model <span class="ot">&lt;-</span> <span class="cf">function</span>(data, <span class="at">p =</span> <span class="cn">NULL</span>) {</span>
<span id="cb1-649"><a href="#cb1-649" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.null</span>(p)) <span class="fu">p</span>()</span>
<span id="cb1-650"><a href="#cb1-650" aria-hidden="true" tabindex="-1"></a>  preds <span class="ot">&lt;-</span> <span class="fu">numeric</span>(<span class="fu">nrow</span>(data))</span>
<span id="cb1-651"><a href="#cb1-651" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span>(t <span class="cf">in</span> <span class="dv">200</span><span class="sc">:</span><span class="fu">nrow</span>(data)) {</span>
<span id="cb1-652"><a href="#cb1-652" aria-hidden="true" tabindex="-1"></a>    model <span class="ot">&lt;-</span> ranger<span class="sc">::</span><span class="fu">ranger</span>(y <span class="sc">~</span> X1 <span class="sc">+</span> X2 <span class="sc">+</span> X3 <span class="sc">+</span> X4 <span class="sc">+</span> X5 <span class="sc">+</span> X6, <span class="at">data =</span> data[<span class="dv">1</span><span class="sc">:</span>(t <span class="sc">-</span> <span class="dv">1</span>),])</span>
<span id="cb1-653"><a href="#cb1-653" aria-hidden="true" tabindex="-1"></a>    preds[t] <span class="ot">&lt;-</span> <span class="fu">predict</span>(model, <span class="at">data =</span> data[t, ])<span class="sc">$</span>predictions</span>
<span id="cb1-654"><a href="#cb1-654" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-655"><a href="#cb1-655" aria-hidden="true" tabindex="-1"></a>  preds</span>
<span id="cb1-656"><a href="#cb1-656" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-657"><a href="#cb1-657" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-658"><a href="#cb1-658" aria-hidden="true" tabindex="-1"></a>metrics <span class="ot">&lt;-</span> <span class="cf">function</span>(fit) {</span>
<span id="cb1-659"><a href="#cb1-659" aria-hidden="true" tabindex="-1"></a>  indices <span class="ot">&lt;-</span> <span class="dv">300</span><span class="sc">:</span><span class="fu">length</span>(fit<span class="sc">$</span>Y)</span>
<span id="cb1-660"><a href="#cb1-660" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci_metrics</span>(fit, indices)</span>
<span id="cb1-661"><a href="#cb1-661" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-662"><a href="#cb1-662" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-663"><a href="#cb1-663" aria-hidden="true" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="cf">function</span>(data, preds, method, alpha, <span class="at">p =</span> <span class="cn">NULL</span>) {</span>
<span id="cb1-664"><a href="#cb1-664" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.null</span>(p)) <span class="fu">p</span>()</span>
<span id="cb1-665"><a href="#cb1-665" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-666"><a href="#cb1-666" aria-hidden="true" tabindex="-1"></a>  D <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">abs</span>(data<span class="sc">$</span>y <span class="sc">-</span> preds)[<span class="dv">200</span><span class="sc">:</span><span class="dv">249</span>])</span>
<span id="cb1-667"><a href="#cb1-667" aria-hidden="true" tabindex="-1"></a>  gamma <span class="ot">&lt;-</span> D <span class="sc">/</span> <span class="fu">sqrt</span>(<span class="dv">3</span>)</span>
<span id="cb1-668"><a href="#cb1-668" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-669"><a href="#cb1-669" aria-hidden="true" tabindex="-1"></a>  interval_constructor <span class="ot">=</span> <span class="fu">case_when</span>(</span>
<span id="cb1-670"><a href="#cb1-670" aria-hidden="true" tabindex="-1"></a>    method <span class="sc">==</span> <span class="st">"AgACI"</span> <span class="sc">~</span> <span class="st">"conformal"</span>,</span>
<span id="cb1-671"><a href="#cb1-671" aria-hidden="true" tabindex="-1"></a>    method <span class="sc">==</span> <span class="st">"FACI"</span> <span class="sc">~</span> <span class="st">"conformal"</span>,</span>
<span id="cb1-672"><a href="#cb1-672" aria-hidden="true" tabindex="-1"></a>    method <span class="sc">==</span> <span class="st">"SF-OGD"</span> <span class="sc">~</span> <span class="st">"linear"</span>,</span>
<span id="cb1-673"><a href="#cb1-673" aria-hidden="true" tabindex="-1"></a>    method <span class="sc">==</span> <span class="st">"SAOCP"</span> <span class="sc">~</span> <span class="st">"linear"</span></span>
<span id="cb1-674"><a href="#cb1-674" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-675"><a href="#cb1-675" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-676"><a href="#cb1-676" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(interval_constructor <span class="sc">==</span> <span class="st">"linear"</span>) {</span>
<span id="cb1-677"><a href="#cb1-677" aria-hidden="true" tabindex="-1"></a>    gamma_grid <span class="ot">=</span> <span class="fu">seq</span>(<span class="fl">0.1</span>, <span class="dv">1</span>, <span class="fl">0.1</span>)</span>
<span id="cb1-678"><a href="#cb1-678" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-679"><a href="#cb1-679" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> {</span>
<span id="cb1-680"><a href="#cb1-680" aria-hidden="true" tabindex="-1"></a>    gamma_grid <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.001</span>, <span class="fl">0.002</span>, <span class="fl">0.004</span>, <span class="fl">0.008</span>, <span class="fl">0.016</span>, <span class="fl">0.032</span>, <span class="fl">0.064</span>, <span class="fl">0.128</span>)</span>
<span id="cb1-681"><a href="#cb1-681" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-682"><a href="#cb1-682" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-683"><a href="#cb1-683" aria-hidden="true" tabindex="-1"></a>  parameters <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb1-684"><a href="#cb1-684" aria-hidden="true" tabindex="-1"></a>    <span class="at">interval_constructor =</span> interval_constructor, </span>
<span id="cb1-685"><a href="#cb1-685" aria-hidden="true" tabindex="-1"></a>    <span class="at">D =</span> D, </span>
<span id="cb1-686"><a href="#cb1-686" aria-hidden="true" tabindex="-1"></a>    <span class="at">gamma =</span> gamma, </span>
<span id="cb1-687"><a href="#cb1-687" aria-hidden="true" tabindex="-1"></a>    <span class="at">gamma_grid =</span> gamma_grid</span>
<span id="cb1-688"><a href="#cb1-688" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-689"><a href="#cb1-689" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-690"><a href="#cb1-690" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(</span>
<span id="cb1-691"><a href="#cb1-691" aria-hidden="true" tabindex="-1"></a>    data<span class="sc">$</span>y[<span class="dv">250</span><span class="sc">:</span><span class="fu">nrow</span>(data)], </span>
<span id="cb1-692"><a href="#cb1-692" aria-hidden="true" tabindex="-1"></a>    preds[<span class="dv">250</span><span class="sc">:</span><span class="fu">nrow</span>(data)], </span>
<span id="cb1-693"><a href="#cb1-693" aria-hidden="true" tabindex="-1"></a>    <span class="at">method =</span> method, </span>
<span id="cb1-694"><a href="#cb1-694" aria-hidden="true" tabindex="-1"></a>    <span class="at">alpha =</span> alpha, </span>
<span id="cb1-695"><a href="#cb1-695" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> parameters</span>
<span id="cb1-696"><a href="#cb1-696" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-697"><a href="#cb1-697" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-698"><a href="#cb1-698" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-699"><a href="#cb1-699" aria-hidden="true" tabindex="-1"></a>N_sims <span class="ot">&lt;-</span> <span class="dv">25</span></span>
<span id="cb1-700"><a href="#cb1-700" aria-hidden="true" tabindex="-1"></a>simulation_data <span class="ot">&lt;-</span> <span class="fu">expand_grid</span>(</span>
<span id="cb1-701"><a href="#cb1-701" aria-hidden="true" tabindex="-1"></a>  <span class="at">index =</span> <span class="dv">1</span><span class="sc">:</span>N_sims,</span>
<span id="cb1-702"><a href="#cb1-702" aria-hidden="true" tabindex="-1"></a>  <span class="at">param =</span>  <span class="fu">c</span>(<span class="fl">0.1</span>, <span class="fl">0.8</span>, <span class="fl">0.9</span>, <span class="fl">0.95</span>, <span class="fl">0.99</span>),</span>
<span id="cb1-703"><a href="#cb1-703" aria-hidden="true" tabindex="-1"></a>  <span class="at">N =</span> <span class="dv">600</span></span>
<span id="cb1-704"><a href="#cb1-704" aria-hidden="true" tabindex="-1"></a>) <span class="sc">%&gt;%</span></span>
<span id="cb1-705"><a href="#cb1-705" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">psi =</span> param, <span class="at">xi =</span> param)</span>
<span id="cb1-706"><a href="#cb1-706" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-707"><a href="#cb1-707" aria-hidden="true" tabindex="-1"></a><span class="co"># For each simulated dataset, fit multiple ACI methods</span></span>
<span id="cb1-708"><a href="#cb1-708" aria-hidden="true" tabindex="-1"></a>simulation_study_setup <span class="ot">&lt;-</span> <span class="fu">expand_grid</span>(</span>
<span id="cb1-709"><a href="#cb1-709" aria-hidden="true" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="fu">c</span>(<span class="fl">0.8</span>, <span class="fl">0.9</span>, <span class="fl">0.95</span>),</span>
<span id="cb1-710"><a href="#cb1-710" aria-hidden="true" tabindex="-1"></a>  <span class="at">method =</span> <span class="fu">c</span>(<span class="st">"AgACI"</span>, <span class="st">"SF-OGD"</span>, <span class="st">"SAOCP"</span>, <span class="st">"FACI"</span>)</span>
<span id="cb1-711"><a href="#cb1-711" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-712"><a href="#cb1-712" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-713"><a href="#cb1-713" aria-hidden="true" tabindex="-1"></a>simulation_study1 <span class="ot">&lt;-</span> <span class="fu">run_simulation_study1</span>(</span>
<span id="cb1-714"><a href="#cb1-714" aria-hidden="true" tabindex="-1"></a>  simulation_data,</span>
<span id="cb1-715"><a href="#cb1-715" aria-hidden="true" tabindex="-1"></a>  simulation_study_setup,</span>
<span id="cb1-716"><a href="#cb1-716" aria-hidden="true" tabindex="-1"></a>  estimate_model,</span>
<span id="cb1-717"><a href="#cb1-717" aria-hidden="true" tabindex="-1"></a>  fit,</span>
<span id="cb1-718"><a href="#cb1-718" aria-hidden="true" tabindex="-1"></a>  <span class="at">workers =</span> <span class="dv">8</span></span>
<span id="cb1-719"><a href="#cb1-719" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-720"><a href="#cb1-720" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-721"><a href="#cb1-721" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-722"><a href="#cb1-722" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-723"><a href="#cb1-723" aria-hidden="true" tabindex="-1"></a>The coverage errors, mean interval widths, and path lengths of each of the algorithms for $\alpha = 0.9$ are shown in @fig-simulation-one-results (results for $\alpha \in <span class="sc">\{</span> 0.8, 0.95 <span class="sc">\}</span>$ were similar and are available in the appendix). All methods achieved near optimal empirical coverage, although SAOCP tended to slightly undercover. The mean interval widths were similar across methods, although again SAOCP had slightly shorter intervals (as could be expected given its tendency to undercover). The path length of SAOCP was larger than any of the other methods. To investigate why, @fig-simulation-one-example plots $w_t - w_{t-1}$, the difference in interval width between times $t-1$ and $t$, for each method in one of the simulations. The interval widths for AgACI and FACI change slowly relative to those for SF-OGD and SAOCP. For SAOCP, we can see the interval widths have larger fluctuations than for the other methods, explaining its higher path width. </span>
<span id="cb1-724"><a href="#cb1-724" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-725"><a href="#cb1-725" aria-hidden="true" tabindex="-1"></a><span class="in">```{r simulation_one_plot, message=FALSE, warning=FALSE}</span></span>
<span id="cb1-726"><a href="#cb1-726" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-simulation-one-results</span></span>
<span id="cb1-727"><a href="#cb1-727" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 6.5</span></span>
<span id="cb1-728"><a href="#cb1-728" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Coverage errors, mean interval widths, and path lengths for the first simulation study with target coverage $\\alpha = 0.9$."</span></span>
<span id="cb1-729"><a href="#cb1-729" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-730"><a href="#cb1-730" aria-hidden="true" tabindex="-1"></a><span class="fu">simulation_one_plot</span>(simulation_study1<span class="sc">$</span>results <span class="sc">%&gt;%</span> <span class="fu">filter</span>(alpha <span class="sc">==</span> <span class="fl">0.9</span>))</span>
<span id="cb1-731"><a href="#cb1-731" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-732"><a href="#cb1-732" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-733"><a href="#cb1-733" aria-hidden="true" tabindex="-1"></a><span class="in">```{r simulation_one_example_plot}</span></span>
<span id="cb1-734"><a href="#cb1-734" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-simulation-one-example</span></span>
<span id="cb1-735"><a href="#cb1-735" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 5</span></span>
<span id="cb1-736"><a href="#cb1-736" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Difference in successive interval widths ($w_t - w_{t-1}$) from an illustrative simulation from the first simulation study."</span></span>
<span id="cb1-737"><a href="#cb1-737" aria-hidden="true" tabindex="-1"></a>fits <span class="ot">&lt;-</span> simulation_study1<span class="sc">$</span>example_fits</span>
<span id="cb1-738"><a href="#cb1-738" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-739"><a href="#cb1-739" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">2</span>, <span class="dv">1</span>))</span>
<span id="cb1-740"><a href="#cb1-740" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>) {</span>
<span id="cb1-741"><a href="#cb1-741" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot</span>(</span>
<span id="cb1-742"><a href="#cb1-742" aria-hidden="true" tabindex="-1"></a>    <span class="fu">diff</span>(fits<span class="sc">$</span>fit[[i]]<span class="sc">$</span>intervals[,<span class="dv">2</span>] <span class="sc">-</span> fits<span class="sc">$</span>fit[[i]]<span class="sc">$</span>intervals[,<span class="dv">1</span>]), </span>
<span id="cb1-743"><a href="#cb1-743" aria-hidden="true" tabindex="-1"></a>    <span class="at">main =</span> fits<span class="sc">$</span>method[[i]], </span>
<span id="cb1-744"><a href="#cb1-744" aria-hidden="true" tabindex="-1"></a>    <span class="at">xlab =</span> <span class="st">"T"</span>, </span>
<span id="cb1-745"><a href="#cb1-745" aria-hidden="true" tabindex="-1"></a>    <span class="at">ylab =</span> <span class="fu">expression</span>(w[t] <span class="sc">-</span> w[t <span class="sc">-</span> <span class="dv">1</span>]))</span>
<span id="cb1-746"><a href="#cb1-746" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-747"><a href="#cb1-747" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="fl">5.1</span>, <span class="fl">4.1</span>, <span class="fl">4.1</span>, <span class="fl">2.1</span>))</span>
<span id="cb1-748"><a href="#cb1-748" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-749"><a href="#cb1-749" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-750"><a href="#cb1-750" aria-hidden="true" tabindex="-1"></a><span class="fu">## Distribution shift</span></span>
<span id="cb1-751"><a href="#cb1-751" aria-hidden="true" tabindex="-1"></a>This simulation study features time series with distribution shifts. The setup is quite simple in order to probe the basic performance of the methods in response to distribution shift. As a baseline, we simulate time series of independent data with</span>
<span id="cb1-752"><a href="#cb1-752" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-753"><a href="#cb1-753" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-754"><a href="#cb1-754" aria-hidden="true" tabindex="-1"></a>  y_t &amp;\sim N(0, \sigma_t^2), <span class="sc">\\</span></span>
<span id="cb1-755"><a href="#cb1-755" aria-hidden="true" tabindex="-1"></a>  \sigma_t &amp;= 0.2,</span>
<span id="cb1-756"><a href="#cb1-756" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-757"><a href="#cb1-757" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-758"><a href="#cb1-758" aria-hidden="true" tabindex="-1"></a>for all $t \in \llbracket T \rrbracket$ ($T = 500$). In the second type of time series, the observations are still independent but their variance increases halfway through the time series:</span>
<span id="cb1-759"><a href="#cb1-759" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-760"><a href="#cb1-760" aria-hidden="true" tabindex="-1"></a>\begin{aligned}</span>
<span id="cb1-761"><a href="#cb1-761" aria-hidden="true" tabindex="-1"></a>y_t &amp;\sim N(0, \sigma_t^2), <span class="sc">\\</span></span>
<span id="cb1-762"><a href="#cb1-762" aria-hidden="true" tabindex="-1"></a>\sigma_t &amp;= 0.2 + 0.5 \mathbb{I}<span class="co">[</span><span class="ot">t &gt; 250</span><span class="co">]</span>.</span>
<span id="cb1-763"><a href="#cb1-763" aria-hidden="true" tabindex="-1"></a>\end{aligned}</span>
<span id="cb1-764"><a href="#cb1-764" aria-hidden="true" tabindex="-1"></a>$$</span>
<span id="cb1-765"><a href="#cb1-765" aria-hidden="true" tabindex="-1"></a>In each case, the ACI algorithms are provided with the unbiased predictions $\hat{\mu}_t = 0$, $t \in \llbracket T \rrbracket$. Fifty simulated datasets were generated for each type of time series.</span>
<span id="cb1-766"><a href="#cb1-766" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-767"><a href="#cb1-767" aria-hidden="true" tabindex="-1"></a><span class="in">```{r simulation_two, cache = TRUE}</span></span>
<span id="cb1-768"><a href="#cb1-768" aria-hidden="true" tabindex="-1"></a>simulate <span class="ot">&lt;-</span> <span class="cf">function</span>(seed, <span class="at">distribution_shift =</span> <span class="dv">0</span>, <span class="at">N =</span> <span class="fl">1e3</span>, <span class="at">sigma =</span> <span class="fl">0.2</span>) {</span>
<span id="cb1-769"><a href="#cb1-769" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(seed)</span>
<span id="cb1-770"><a href="#cb1-770" aria-hidden="true" tabindex="-1"></a>  mu <span class="ot">&lt;-</span> <span class="fu">rep</span>(<span class="dv">0</span>, N)</span>
<span id="cb1-771"><a href="#cb1-771" aria-hidden="true" tabindex="-1"></a>  shift <span class="ot">&lt;-</span> <span class="dv">1</span><span class="sc">:</span>N <span class="sc">&gt;</span> (N <span class="sc">/</span> <span class="dv">2</span>)</span>
<span id="cb1-772"><a href="#cb1-772" aria-hidden="true" tabindex="-1"></a>  muhat <span class="ot">&lt;-</span> mu</span>
<span id="cb1-773"><a href="#cb1-773" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> <span class="fu">rnorm</span>(<span class="at">n =</span> <span class="fu">length</span>(mu), <span class="at">mean =</span> mu, <span class="at">sd =</span> sigma <span class="sc">+</span> <span class="fu">ifelse</span>(shift, distribution_shift, <span class="dv">0</span>))</span>
<span id="cb1-774"><a href="#cb1-774" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-775"><a href="#cb1-775" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tibble</span>(<span class="at">y =</span> y, <span class="at">muhat =</span> muhat)</span>
<span id="cb1-776"><a href="#cb1-776" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-777"><a href="#cb1-777" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-778"><a href="#cb1-778" aria-hidden="true" tabindex="-1"></a>metrics <span class="ot">&lt;-</span> <span class="cf">function</span>(fit) {</span>
<span id="cb1-779"><a href="#cb1-779" aria-hidden="true" tabindex="-1"></a>  N <span class="ot">&lt;-</span> <span class="fu">length</span>(fit<span class="sc">$</span>Y)</span>
<span id="cb1-780"><a href="#cb1-780" aria-hidden="true" tabindex="-1"></a>  indices <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="dv">1</span><span class="sc">:</span>N <span class="sc">&gt;</span> <span class="dv">50</span>)</span>
<span id="cb1-781"><a href="#cb1-781" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci_metrics</span>(fit, indices)</span>
<span id="cb1-782"><a href="#cb1-782" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-783"><a href="#cb1-783" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-784"><a href="#cb1-784" aria-hidden="true" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="cf">function</span>(data, method, alpha, <span class="at">p =</span> <span class="cn">NULL</span>) {</span>
<span id="cb1-785"><a href="#cb1-785" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span><span class="fu">is.null</span>(p)) <span class="fu">p</span>()</span>
<span id="cb1-786"><a href="#cb1-786" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-787"><a href="#cb1-787" aria-hidden="true" tabindex="-1"></a>  interval_constructor <span class="ot">=</span> <span class="fu">case_when</span>(</span>
<span id="cb1-788"><a href="#cb1-788" aria-hidden="true" tabindex="-1"></a>    method <span class="sc">==</span> <span class="st">"AgACI"</span> <span class="sc">~</span> <span class="st">"conformal"</span>,</span>
<span id="cb1-789"><a href="#cb1-789" aria-hidden="true" tabindex="-1"></a>    method <span class="sc">==</span> <span class="st">"FACI"</span> <span class="sc">~</span> <span class="st">"conformal"</span>,</span>
<span id="cb1-790"><a href="#cb1-790" aria-hidden="true" tabindex="-1"></a>    method <span class="sc">==</span> <span class="st">"SF-OGD"</span> <span class="sc">~</span> <span class="st">"linear"</span>,</span>
<span id="cb1-791"><a href="#cb1-791" aria-hidden="true" tabindex="-1"></a>    method <span class="sc">==</span> <span class="st">"SAOCP"</span> <span class="sc">~</span> <span class="st">"linear"</span></span>
<span id="cb1-792"><a href="#cb1-792" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-793"><a href="#cb1-793" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-794"><a href="#cb1-794" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(interval_constructor <span class="sc">==</span> <span class="st">"linear"</span>) {</span>
<span id="cb1-795"><a href="#cb1-795" aria-hidden="true" tabindex="-1"></a>    D <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">abs</span>(data<span class="sc">$</span>y <span class="sc">-</span> data<span class="sc">$</span>muhat)[<span class="dv">1</span><span class="sc">:</span><span class="dv">50</span>])</span>
<span id="cb1-796"><a href="#cb1-796" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-797"><a href="#cb1-797" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> {</span>
<span id="cb1-798"><a href="#cb1-798" aria-hidden="true" tabindex="-1"></a>    D <span class="ot">&lt;-</span> <span class="dv">1</span></span>
<span id="cb1-799"><a href="#cb1-799" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-800"><a href="#cb1-800" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-801"><a href="#cb1-801" aria-hidden="true" tabindex="-1"></a>  gamma <span class="ot">&lt;-</span> D <span class="sc">/</span> <span class="fu">sqrt</span>(<span class="dv">3</span>)</span>
<span id="cb1-802"><a href="#cb1-802" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-803"><a href="#cb1-803" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(interval_constructor <span class="sc">==</span> <span class="st">"linear"</span>) {</span>
<span id="cb1-804"><a href="#cb1-804" aria-hidden="true" tabindex="-1"></a>    gamma_grid <span class="ot">&lt;-</span> <span class="fu">seq</span>(<span class="fl">0.1</span>, <span class="dv">2</span>, <span class="fl">0.1</span>)</span>
<span id="cb1-805"><a href="#cb1-805" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-806"><a href="#cb1-806" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> {</span>
<span id="cb1-807"><a href="#cb1-807" aria-hidden="true" tabindex="-1"></a>    gamma_grid <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.001</span>, <span class="fl">0.002</span>, <span class="fl">0.004</span>, <span class="fl">0.008</span>, <span class="fl">0.016</span>, <span class="fl">0.032</span>, <span class="fl">0.064</span>, <span class="fl">0.128</span>)</span>
<span id="cb1-808"><a href="#cb1-808" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-809"><a href="#cb1-809" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-810"><a href="#cb1-810" aria-hidden="true" tabindex="-1"></a>  parameters <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb1-811"><a href="#cb1-811" aria-hidden="true" tabindex="-1"></a>    <span class="at">interval_constructor =</span> interval_constructor, </span>
<span id="cb1-812"><a href="#cb1-812" aria-hidden="true" tabindex="-1"></a>    <span class="at">D =</span> D, </span>
<span id="cb1-813"><a href="#cb1-813" aria-hidden="true" tabindex="-1"></a>    <span class="at">gamma =</span> gamma, </span>
<span id="cb1-814"><a href="#cb1-814" aria-hidden="true" tabindex="-1"></a>    <span class="at">gamma_grid =</span> gamma_grid</span>
<span id="cb1-815"><a href="#cb1-815" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-816"><a href="#cb1-816" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-817"><a href="#cb1-817" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(data<span class="sc">$</span>y, data<span class="sc">$</span>muhat, <span class="at">method =</span> method, <span class="at">alpha =</span> alpha, <span class="at">parameters =</span> parameters)</span>
<span id="cb1-818"><a href="#cb1-818" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-819"><a href="#cb1-819" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-820"><a href="#cb1-820" aria-hidden="true" tabindex="-1"></a>N_sims <span class="ot">&lt;-</span> <span class="fl">5e1</span></span>
<span id="cb1-821"><a href="#cb1-821" aria-hidden="true" tabindex="-1"></a>simulation_study_setup2 <span class="ot">&lt;-</span> <span class="fu">expand_grid</span>(</span>
<span id="cb1-822"><a href="#cb1-822" aria-hidden="true" tabindex="-1"></a>  <span class="at">index =</span> <span class="dv">1</span><span class="sc">:</span>N_sims,</span>
<span id="cb1-823"><a href="#cb1-823" aria-hidden="true" tabindex="-1"></a>  <span class="at">distribution_shift =</span> <span class="fu">c</span>(<span class="dv">0</span>, <span class="fl">0.5</span>),</span>
<span id="cb1-824"><a href="#cb1-824" aria-hidden="true" tabindex="-1"></a>  <span class="at">alpha =</span> <span class="fu">c</span>(<span class="fl">0.8</span>, <span class="fl">0.9</span>, <span class="fl">0.95</span>),</span>
<span id="cb1-825"><a href="#cb1-825" aria-hidden="true" tabindex="-1"></a>  <span class="at">N =</span> <span class="dv">500</span>,</span>
<span id="cb1-826"><a href="#cb1-826" aria-hidden="true" tabindex="-1"></a>  <span class="at">method =</span> <span class="fu">c</span>(<span class="st">"AgACI"</span>, <span class="st">"SF-OGD"</span>, <span class="st">"SAOCP"</span>, <span class="st">"FACI"</span>),</span>
<span id="cb1-827"><a href="#cb1-827" aria-hidden="true" tabindex="-1"></a>) <span class="sc">%&gt;%</span></span>
<span id="cb1-828"><a href="#cb1-828" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">data =</span> <span class="fu">pmap</span>(<span class="fu">list</span>(index, distribution_shift, N), simulate))</span>
<span id="cb1-829"><a href="#cb1-829" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-830"><a href="#cb1-830" aria-hidden="true" tabindex="-1"></a>simulation_study2 <span class="ot">&lt;-</span> <span class="fu">run_simulation_study2</span>(simulation_study_setup2, fit, <span class="at">workers =</span> <span class="dv">8</span>)</span>
<span id="cb1-831"><a href="#cb1-831" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-832"><a href="#cb1-832" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-833"><a href="#cb1-833" aria-hidden="true" tabindex="-1"></a>The coverage error, mean path length, and mean interval widths of the algorithms are summarized in @fig-simulation-two-joint (an alternative plot is included in the appendix as @fig-simulation-two-results). The coverage error of all the algorithms is near the desired value in the absence of distribution shift. On the contrary, all of the algorithms except AgACI and FACI undercover when there is distributional shift. SAOCP tends to have higher average path lengths than the other methods. An illustrative example of prediction intervals generated by each method for one of the simulated time series with distribution shift is shown in @fig-simulation-two-example. The SAOCP prediction intervals in the example before the distribution shift are more jagged than those produced by the other methods, which illustrates why SAOCP may have longer path lengths.</span>
<span id="cb1-834"><a href="#cb1-834" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-835"><a href="#cb1-835" aria-hidden="true" tabindex="-1"></a><span class="in">```{r simulation_two_plot_joint, echo=FALSE}</span></span>
<span id="cb1-836"><a href="#cb1-836" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-simulation-two-joint</span></span>
<span id="cb1-837"><a href="#cb1-837" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Mean interval width vs coverage error (top) and Mean Path Length vs. coverage error (bottom) for the second simulation study. The error bars represent the 10% to 90% quantiles of the metrics over the simulation datasets."</span></span>
<span id="cb1-838"><a href="#cb1-838" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 6</span></span>
<span id="cb1-839"><a href="#cb1-839" aria-hidden="true" tabindex="-1"></a><span class="fu">simulation_two_joint_plot</span>(simulation_study2<span class="sc">$</span>results)</span>
<span id="cb1-840"><a href="#cb1-840" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-841"><a href="#cb1-841" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-842"><a href="#cb1-842" aria-hidden="true" tabindex="-1"></a><span class="in">```{r simulation_two_example_plot}</span></span>
<span id="cb1-843"><a href="#cb1-843" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-simulation-two-example</span></span>
<span id="cb1-844"><a href="#cb1-844" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 6</span></span>
<span id="cb1-845"><a href="#cb1-845" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Example prediction intervals (target coverage $\\alpha = 0.9$) from the second simulation study of time series with distributional shift, in which the shift occurs at time 250. Blue and red points are observations that fell inside and outside the prediction intervals, respectively."</span></span>
<span id="cb1-846"><a href="#cb1-846" aria-hidden="true" tabindex="-1"></a>fits <span class="ot">&lt;-</span> simulation_study2<span class="sc">$</span>example_fits</span>
<span id="cb1-847"><a href="#cb1-847" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-848"><a href="#cb1-848" aria-hidden="true" tabindex="-1"></a>coverage    <span class="ot">&lt;-</span> <span class="fu">format_coverage</span>(<span class="fu">extract_metric</span>(fits<span class="sc">$</span>fit, <span class="st">"coverage"</span>))</span>
<span id="cb1-849"><a href="#cb1-849" aria-hidden="true" tabindex="-1"></a>path_length <span class="ot">&lt;-</span> <span class="fu">format_path_length</span>(<span class="fu">extract_metric</span>(fits<span class="sc">$</span>fit, <span class="st">"path_length"</span>))</span>
<span id="cb1-850"><a href="#cb1-850" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-851"><a href="#cb1-851" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">1</span>))</span>
<span id="cb1-852"><a href="#cb1-852" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">4</span>) {</span>
<span id="cb1-853"><a href="#cb1-853" aria-hidden="true" tabindex="-1"></a>  <span class="fu">plot</span>(fits<span class="sc">$</span>fit[[i]], <span class="at">legend =</span> <span class="cn">FALSE</span>, <span class="at">main =</span> fits<span class="sc">$</span>method[[i]], <span class="at">index =</span> <span class="dv">51</span><span class="sc">:</span><span class="dv">500</span>)</span>
<span id="cb1-854"><a href="#cb1-854" aria-hidden="true" tabindex="-1"></a>  <span class="fu">text</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">y =</span> <span class="sc">-</span><span class="fl">1.5</span>, <span class="at">labels =</span> <span class="fu">bquote</span>(EmpCov <span class="sc">==</span> .(coverage[[i]]) ), <span class="at">pos =</span> <span class="dv">4</span>)</span>
<span id="cb1-855"><a href="#cb1-855" aria-hidden="true" tabindex="-1"></a>  <span class="fu">text</span>(<span class="at">x =</span> <span class="sc">-</span><span class="dv">10</span>, <span class="at">y =</span> <span class="sc">-</span><span class="dv">2</span>, <span class="at">labels =</span> <span class="fu">bquote</span>(PathLength <span class="sc">==</span> .(path_length[[i]]) ), <span class="at">pos =</span> <span class="dv">4</span>)</span>
<span id="cb1-856"><a href="#cb1-856" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-857"><a href="#cb1-857" aria-hidden="true" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">1</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="fl">5.1</span>, <span class="fl">4.1</span>, <span class="fl">4.1</span>, <span class="fl">2.1</span>))</span>
<span id="cb1-858"><a href="#cb1-858" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-859"><a href="#cb1-859" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-860"><a href="#cb1-860" aria-hidden="true" tabindex="-1"></a><span class="fu"># Case Study: Influenza Forecasting {#sec-case-study}</span></span>
<span id="cb1-861"><a href="#cb1-861" aria-hidden="true" tabindex="-1"></a>Influenza is a highly infectious disease that is estimated to infect approximately one billion individuals each year around the world <span class="co">[</span><span class="ot">@krammer2018influenza</span><span class="co">]</span>. Influenza incidence in temperate climates tends to follow a seasonal pattern, with the highest number of infections during what is commonly referred to as the \textit{flu season} <span class="co">[</span><span class="ot">@lofgren2007influenza</span><span class="co">]</span>. Accurate forecasting of influenza is of significant interest to aid in public health planning and resource allocation. To investigate the accuracy of influenza forecasts, the US Centers for Disease Control (CDC) initiated a challenge, referred to as FluSight, in which teams from multiple institutions submitted weekly forecasts of influenza incidence <span class="co">[</span><span class="ot">@biggerstaff2016flusight</span><span class="co">]</span>. @reich2019influenza evaluated the accuracy of the forecasts over seven flu seasons from 2010 to 2017. As a case study, we investigate the use of ACI algorithms to augment the FluSight forecasts with prediction intervals.</span>
<span id="cb1-862"><a href="#cb1-862" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-863"><a href="#cb1-863" aria-hidden="true" tabindex="-1"></a>The FluSight challenge collected forecasts for multiple prediction targets. For this case study, we focus on national (US) one-week ahead forecasts of weighted influenza-like illness (wILI), which is a population-weighted percentage of doctors visits where patients presented with influenza-like symptoms <span class="co">[</span><span class="ot">@biggerstaff2016flusight</span><span class="co">]</span>. The FluSight dataset, which is publicy available, include forecasts derived from 21 different forecasting models, from both mechanistic and statistical viewpoints <span class="co">[</span><span class="ot">@tushar2018flusightnetwork, @tushar2019flusight</span><span class="co">]</span>. For our purposes, we treat the way the forecasts were produced as a black box.</span>
<span id="cb1-864"><a href="#cb1-864" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-865"><a href="#cb1-865" aria-hidden="true" tabindex="-1"></a>Formally, let $y_{t}$, $t \in \llbracket T \rrbracket$ be the observed national wILI at time $t$, and let $\hat{\mu}_{j,t}$, $j \in \llbracket J \rrbracket$, be the one-week ahead forecast of the wILI from model $j$ at time $t$. Two of the original 21 forecasting methods were excluded from this case study due to poor predictive performance (\texttt{Delphi<span class="sc">\_</span>Uniform} and \texttt{CUBMA}). In addition, six methods had identical forecasts (\texttt{CU<span class="sc">\_</span>EAKFC<span class="sc">\_</span>SIRS}, \texttt{CU<span class="sc">\_</span>EKF<span class="sc">\_</span>SEIRS}, \texttt{CU<span class="sc">\_</span>EKF<span class="sc">\_</span>SIRS}, \texttt{CU<span class="sc">\_</span>RHF<span class="sc">\_</span>SEIRS}, \texttt{CU<span class="sc">\_</span>RHF<span class="sc">\_</span>SIRS}), and therefore we only included one (\texttt{CU<span class="sc">\_</span>EAKFC<span class="sc">\_</span>SEIRS}) in the analysis. The ACI methods were then applied to the log-observations and log-predictions, where the log-transformation was used to constrain the final prediction intervals to be positive. The first flu season (2010-2011) was used as a warm-up for each ACI method, and we report the empirical performance of the prediction intervals for the subsequent seasons (six seasons from 2012-2013 to 2016-2017). The ACI algorithms target prediction intervals with coverage of $\alpha = 0.8$, $\alpha = 0.9$, and $\alpha = 0.95$. As in the simulation study, we used the interval constructor corresponding to the original presentaiton of each algorithm (see @tbl-aci).  </span>
<span id="cb1-866"><a href="#cb1-866" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-867"><a href="#cb1-867" aria-hidden="true" tabindex="-1"></a><span class="in">```{r case_study, cache = TRUE}</span></span>
<span id="cb1-868"><a href="#cb1-868" aria-hidden="true" tabindex="-1"></a>raw_data <span class="ot">&lt;-</span> <span class="fu">read_csv</span>(<span class="st">"https://raw.githubusercontent.com/FluSightNetwork/cdc-flusight-ensemble/master/scores/point_ests.csv"</span>, <span class="at">show_col_types =</span> <span class="cn">FALSE</span>)</span>
<span id="cb1-869"><a href="#cb1-869" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-870"><a href="#cb1-870" aria-hidden="true" tabindex="-1"></a>fit <span class="ot">&lt;-</span> <span class="cf">function</span>(data, method, alpha) {</span>
<span id="cb1-871"><a href="#cb1-871" aria-hidden="true" tabindex="-1"></a>  first_season <span class="ot">&lt;-</span> data<span class="sc">$</span>Season <span class="sc">==</span> <span class="st">"2010/2011"</span></span>
<span id="cb1-872"><a href="#cb1-872" aria-hidden="true" tabindex="-1"></a>  D <span class="ot">&lt;-</span> <span class="fu">max</span>(<span class="fu">abs</span>(data<span class="sc">$</span>obs_value <span class="sc">-</span> data<span class="sc">$</span>Value)[first_season])</span>
<span id="cb1-873"><a href="#cb1-873" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-874"><a href="#cb1-874" aria-hidden="true" tabindex="-1"></a>  interval_constructor <span class="ot">=</span> <span class="fu">case_when</span>(</span>
<span id="cb1-875"><a href="#cb1-875" aria-hidden="true" tabindex="-1"></a>    method <span class="sc">==</span> <span class="st">"AgACI"</span> <span class="sc">~</span> <span class="st">"conformal"</span>,</span>
<span id="cb1-876"><a href="#cb1-876" aria-hidden="true" tabindex="-1"></a>    method <span class="sc">==</span> <span class="st">"FACI"</span> <span class="sc">~</span> <span class="st">"conformal"</span>,</span>
<span id="cb1-877"><a href="#cb1-877" aria-hidden="true" tabindex="-1"></a>    method <span class="sc">==</span> <span class="st">"SF-OGD"</span> <span class="sc">~</span> <span class="st">"linear"</span>,</span>
<span id="cb1-878"><a href="#cb1-878" aria-hidden="true" tabindex="-1"></a>    method <span class="sc">==</span> <span class="st">"SAOCP"</span> <span class="sc">~</span> <span class="st">"linear"</span></span>
<span id="cb1-879"><a href="#cb1-879" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-880"><a href="#cb1-880" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-881"><a href="#cb1-881" aria-hidden="true" tabindex="-1"></a>  gamma <span class="ot">&lt;-</span> D <span class="sc">/</span> <span class="fu">sqrt</span>(<span class="dv">3</span>)</span>
<span id="cb1-882"><a href="#cb1-882" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-883"><a href="#cb1-883" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span>(interval_constructor <span class="sc">==</span> <span class="st">"linear"</span>) {</span>
<span id="cb1-884"><a href="#cb1-884" aria-hidden="true" tabindex="-1"></a>    gamma_grid <span class="ot">=</span> <span class="fu">seq</span>(<span class="fl">0.1</span>, <span class="dv">1</span>, <span class="fl">0.1</span>)</span>
<span id="cb1-885"><a href="#cb1-885" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-886"><a href="#cb1-886" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span> {</span>
<span id="cb1-887"><a href="#cb1-887" aria-hidden="true" tabindex="-1"></a>    gamma_grid <span class="ot">&lt;-</span> <span class="fu">c</span>(<span class="fl">0.001</span>, <span class="fl">0.002</span>, <span class="fl">0.004</span>, <span class="fl">0.008</span>, <span class="fl">0.016</span>, <span class="fl">0.032</span>, <span class="fl">0.064</span>, <span class="fl">0.128</span>)</span>
<span id="cb1-888"><a href="#cb1-888" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb1-889"><a href="#cb1-889" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-890"><a href="#cb1-890" aria-hidden="true" tabindex="-1"></a>  parameters <span class="ot">&lt;-</span> <span class="fu">list</span>(</span>
<span id="cb1-891"><a href="#cb1-891" aria-hidden="true" tabindex="-1"></a>    <span class="at">interval_constructor =</span> interval_constructor,</span>
<span id="cb1-892"><a href="#cb1-892" aria-hidden="true" tabindex="-1"></a>    <span class="at">D =</span> D, </span>
<span id="cb1-893"><a href="#cb1-893" aria-hidden="true" tabindex="-1"></a>    <span class="at">gamma =</span> gamma, </span>
<span id="cb1-894"><a href="#cb1-894" aria-hidden="true" tabindex="-1"></a>    <span class="at">gamma_grid =</span> gamma_grid</span>
<span id="cb1-895"><a href="#cb1-895" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-896"><a href="#cb1-896" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb1-897"><a href="#cb1-897" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci</span>(</span>
<span id="cb1-898"><a href="#cb1-898" aria-hidden="true" tabindex="-1"></a>    <span class="at">Y =</span> <span class="fu">log</span>(data<span class="sc">$</span>obs_value), </span>
<span id="cb1-899"><a href="#cb1-899" aria-hidden="true" tabindex="-1"></a>    <span class="at">predictions =</span> <span class="fu">log</span>(data<span class="sc">$</span>Value), </span>
<span id="cb1-900"><a href="#cb1-900" aria-hidden="true" tabindex="-1"></a>    <span class="at">method =</span> method, </span>
<span id="cb1-901"><a href="#cb1-901" aria-hidden="true" tabindex="-1"></a>    <span class="at">parameters =</span> parameters, </span>
<span id="cb1-902"><a href="#cb1-902" aria-hidden="true" tabindex="-1"></a>    <span class="at">alpha =</span> alpha</span>
<span id="cb1-903"><a href="#cb1-903" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-904"><a href="#cb1-904" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-905"><a href="#cb1-905" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-906"><a href="#cb1-906" aria-hidden="true" tabindex="-1"></a>metrics <span class="ot">&lt;-</span> <span class="cf">function</span>(data, fit) {</span>
<span id="cb1-907"><a href="#cb1-907" aria-hidden="true" tabindex="-1"></a>  <span class="fu">aci_metrics</span>(fit, <span class="at">indices =</span> <span class="fu">which</span>(data<span class="sc">$</span>Season <span class="sc">!=</span> <span class="st">"2010/2011"</span>))</span>
<span id="cb1-908"><a href="#cb1-908" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-909"><a href="#cb1-909" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-910"><a href="#cb1-910" aria-hidden="true" tabindex="-1"></a>analysis_data <span class="ot">&lt;-</span> raw_data <span class="sc">%&gt;%</span></span>
<span id="cb1-911"><a href="#cb1-911" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(</span>
<span id="cb1-912"><a href="#cb1-912" aria-hidden="true" tabindex="-1"></a>    Target <span class="sc">==</span> <span class="st">"1 wk ahead"</span>, </span>
<span id="cb1-913"><a href="#cb1-913" aria-hidden="true" tabindex="-1"></a>    Location <span class="sc">==</span> <span class="st">"US National"</span>, </span>
<span id="cb1-914"><a href="#cb1-914" aria-hidden="true" tabindex="-1"></a>    <span class="sc">!</span>(model_name <span class="sc">%in%</span> <span class="fu">c</span>(<span class="st">"Delphi_Uniform"</span>, <span class="st">"CUBMA"</span>, <span class="st">"CU_EAKFC_SIRS"</span>, <span class="st">"CU_EKF_SEIRS"</span>, <span class="st">"CU_EKF_SIRS"</span>, <span class="st">"CU_RHF_SEIRS"</span>, <span class="st">"CU_RHF_SIRS"</span>))</span>
<span id="cb1-915"><a href="#cb1-915" aria-hidden="true" tabindex="-1"></a>  ) <span class="sc">%&gt;%</span></span>
<span id="cb1-916"><a href="#cb1-916" aria-hidden="true" tabindex="-1"></a>  <span class="fu">arrange</span>(Year, Model.Week) <span class="sc">%&gt;%</span></span>
<span id="cb1-917"><a href="#cb1-917" aria-hidden="true" tabindex="-1"></a>  <span class="fu">group_by</span>(model_name) <span class="sc">%&gt;%</span></span>
<span id="cb1-918"><a href="#cb1-918" aria-hidden="true" tabindex="-1"></a>  <span class="fu">nest</span>() </span>
<span id="cb1-919"><a href="#cb1-919" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-920"><a href="#cb1-920" aria-hidden="true" tabindex="-1"></a>fits <span class="ot">&lt;-</span> <span class="fu">expand_grid</span>(</span>
<span id="cb1-921"><a href="#cb1-921" aria-hidden="true" tabindex="-1"></a>  analysis_data, </span>
<span id="cb1-922"><a href="#cb1-922" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tibble</span>(<span class="at">method =</span> <span class="fu">c</span>(<span class="st">"AgACI"</span>, <span class="st">"FACI"</span>, <span class="st">"SF-OGD"</span>, <span class="st">"SAOCP"</span>)), </span>
<span id="cb1-923"><a href="#cb1-923" aria-hidden="true" tabindex="-1"></a>  <span class="fu">tibble</span>(<span class="at">alpha =</span> <span class="fu">c</span>(<span class="fl">0.8</span>, <span class="fl">0.9</span>, <span class="fl">0.95</span>))</span>
<span id="cb1-924"><a href="#cb1-924" aria-hidden="true" tabindex="-1"></a>) <span class="sc">%&gt;%</span></span>
<span id="cb1-925"><a href="#cb1-925" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">fit =</span> <span class="fu">pmap</span>(<span class="fu">list</span>(data, method, alpha), fit),</span>
<span id="cb1-926"><a href="#cb1-926" aria-hidden="true" tabindex="-1"></a>         <span class="at">metrics =</span> <span class="fu">map2</span>(data, fit, metrics))</span>
<span id="cb1-927"><a href="#cb1-927" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-928"><a href="#cb1-928" aria-hidden="true" tabindex="-1"></a>case_study_results <span class="ot">&lt;-</span> fits <span class="sc">%&gt;%</span></span>
<span id="cb1-929"><a href="#cb1-929" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(<span class="sc">-</span>data, <span class="sc">-</span>fit) <span class="sc">%&gt;%</span></span>
<span id="cb1-930"><a href="#cb1-930" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">metrics =</span> <span class="fu">map</span>(metrics, as_tibble)) <span class="sc">%&gt;%</span></span>
<span id="cb1-931"><a href="#cb1-931" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unnest</span>(<span class="fu">c</span>(metrics)) </span>
<span id="cb1-932"><a href="#cb1-932" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-933"><a href="#cb1-933" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-934"><a href="#cb1-934" aria-hidden="true" tabindex="-1"></a>The coverage errors, mean interval widths, and path lengths of the prediction intervals for each of the underlying forecast models is shown in @fig-case-study-metrics. In all cases the absolute coverage error was less than $0.1$. SF-OGD performed particularly well, with coverage errors close to zero for all forecasting models. Interval widths were similar across methods, with SAOCP slightly shorter. Path Lengths were shorter for AgACI and FACI and longer for SAOCP.</span>
<span id="cb1-935"><a href="#cb1-935" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-936"><a href="#cb1-936" aria-hidden="true" tabindex="-1"></a><span class="in">```{r case_study_metrics_plot}</span></span>
<span id="cb1-937"><a href="#cb1-937" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-case-study-metrics</span></span>
<span id="cb1-938"><a href="#cb1-938" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 6.5</span></span>
<span id="cb1-939"><a href="#cb1-939" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Coverage errors, mean interval widths, and path lengths of prediction intervals generated with each ACI method based on forecasts from each of the 19 underlying influenza forecasting models."</span></span>
<span id="cb1-940"><a href="#cb1-940" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-941"><a href="#cb1-941" aria-hidden="true" tabindex="-1"></a><span class="fu">case_study_plot</span>(case_study_results)</span>
<span id="cb1-942"><a href="#cb1-942" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-943"><a href="#cb1-943" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-944"><a href="#cb1-944" aria-hidden="true" tabindex="-1"></a>As an illustrative example, in @fig-case-study-example we plot the point forecasts from one of the forecasting models (based on SARIMA with no seasonal differencing) and the associated ACI-generated 90\% prediction intervals for each season from 2011-2017. In general, in this practical setting all of the ACI algorithms yield quite similar prediction intervals. Interestingly, the forecasts in 2011-2012 underpredicted the observations for much of the season. The algorithm responds by making the intervals wider to cover the observations, and because the intervals are symmetric the lower bound then becomes unrealistically low. A similar phenomenon can be seen in the growth phase of the 2012/2013 season as well.</span>
<span id="cb1-945"><a href="#cb1-945" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-946"><a href="#cb1-946" aria-hidden="true" tabindex="-1"></a><span class="in">```{r case_study_example_plot}</span></span>
<span id="cb1-947"><a href="#cb1-947" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-case-study-example</span></span>
<span id="cb1-948"><a href="#cb1-948" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 4</span></span>
<span id="cb1-949"><a href="#cb1-949" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Example conformal prediction intervals for six flu seasons based on forecasts from a SARIMA type model."</span></span>
<span id="cb1-950"><a href="#cb1-950" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-951"><a href="#cb1-951" aria-hidden="true" tabindex="-1"></a>sarima_fits <span class="ot">&lt;-</span> fits <span class="sc">%&gt;%</span> <span class="fu">filter</span>(</span>
<span id="cb1-952"><a href="#cb1-952" aria-hidden="true" tabindex="-1"></a>  model_name <span class="sc">==</span> <span class="st">"ReichLab_sarima_seasonal_difference_FALSE"</span>, </span>
<span id="cb1-953"><a href="#cb1-953" aria-hidden="true" tabindex="-1"></a>  alpha <span class="sc">==</span> <span class="fl">0.9</span></span>
<span id="cb1-954"><a href="#cb1-954" aria-hidden="true" tabindex="-1"></a>) <span class="sc">%&gt;%</span></span>
<span id="cb1-955"><a href="#cb1-955" aria-hidden="true" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">output =</span> <span class="fu">map</span>(fit, extract_intervals)) <span class="sc">%&gt;%</span></span>
<span id="cb1-956"><a href="#cb1-956" aria-hidden="true" tabindex="-1"></a>  <span class="fu">select</span>(method, alpha, data, output) <span class="sc">%&gt;%</span></span>
<span id="cb1-957"><a href="#cb1-957" aria-hidden="true" tabindex="-1"></a>  <span class="fu">unnest</span>(<span class="fu">c</span>(data, output)) <span class="sc">%&gt;%</span></span>
<span id="cb1-958"><a href="#cb1-958" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Season <span class="sc">!=</span> <span class="st">"2010/2011"</span>)</span>
<span id="cb1-959"><a href="#cb1-959" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-960"><a href="#cb1-960" aria-hidden="true" tabindex="-1"></a>sarima_fits <span class="sc">%&gt;%</span></span>
<span id="cb1-961"><a href="#cb1-961" aria-hidden="true" tabindex="-1"></a>  <span class="fu">ggplot</span>(<span class="fu">aes</span>(<span class="at">x =</span> Model.Week, <span class="at">y =</span> <span class="fu">log</span>(obs_value))) <span class="sc">+</span></span>
<span id="cb1-962"><a href="#cb1-962" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>(<span class="fu">aes</span>(<span class="at">shape =</span> <span class="st">"Observed"</span>)) <span class="sc">+</span></span>
<span id="cb1-963"><a href="#cb1-963" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">y =</span> pred, <span class="at">lty =</span> <span class="st">"Forecast"</span>), <span class="at">color =</span> <span class="st">"black"</span>) <span class="sc">+</span></span>
<span id="cb1-964"><a href="#cb1-964" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">y =</span> lower, <span class="at">color =</span> method)) <span class="sc">+</span></span>
<span id="cb1-965"><a href="#cb1-965" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_line</span>(<span class="fu">aes</span>(<span class="at">y =</span> upper, <span class="at">color =</span> method)) <span class="sc">+</span></span>
<span id="cb1-966"><a href="#cb1-966" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_wrap</span>(<span class="sc">~</span>Season) <span class="sc">+</span></span>
<span id="cb1-967"><a href="#cb1-967" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(</span>
<span id="cb1-968"><a href="#cb1-968" aria-hidden="true" tabindex="-1"></a>    <span class="at">x =</span> <span class="st">"Flu Season Week"</span>, </span>
<span id="cb1-969"><a href="#cb1-969" aria-hidden="true" tabindex="-1"></a>    <span class="at">y =</span> <span class="st">"log(wILI)"</span>, </span>
<span id="cb1-970"><a href="#cb1-970" aria-hidden="true" tabindex="-1"></a>    <span class="at">title =</span> <span class="st">"SARIMA forecasts with ACI 90% prediction intervals"</span></span>
<span id="cb1-971"><a href="#cb1-971" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb1-972"><a href="#cb1-972" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-973"><a href="#cb1-973" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-974"><a href="#cb1-974" aria-hidden="true" tabindex="-1"></a><span class="fu"># Discussion {#sec-discussion}</span></span>
<span id="cb1-975"><a href="#cb1-975" aria-hidden="true" tabindex="-1"></a>The results of our simulations and case study show that, when tuning parameters are chosen well, Adaptive Conformal Inference algorithms yield well-performing prediction intervals. On the contrary, poor choice of tuning parameters can lead to intervals of low utility. Furthermore, in some cases the prediction intervals may appear to perform well with respect to metrics like the empirical coverage error, while simultaneously being useless in practice. The original ACI algorithm illustrates this phenomenon: too small a value of its learning rate $\gamma$ yields prediction intervals that are not reactive enough, while too large a value yields intervals that change too fast. In both cases, the empirical coverage may appear well-calibrated, while the prediction intervals will not be useful. Thus, the core challenge in designing an ACI algorithm is in finding an optimal level of reactivity for the prediction intervals. As users of these algorithms, the challenge is in finding values for the tuning parameters that avoid pathological behaviors.</span>
<span id="cb1-976"><a href="#cb1-976" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-977"><a href="#cb1-977" aria-hidden="true" tabindex="-1"></a>Several of the algorithms investigated in this paper handle the problem of finding an optimal level of reactivity by aggregating prediction intervals generated by a set of underlying ACI algorithms. </span>
<span id="cb1-978"><a href="#cb1-978" aria-hidden="true" tabindex="-1"></a>Our results show the algorithms can perform well in multiple difficult scenarios. However, the overall effect of these approaches is to shift the problem to a higher level of abstraction: we still need to set tuning parameters that control the amount of reactivity, but do so at a higher level than the original ACI algorithm. It is desirable that these tuning parameters be easily interpretable, with simple strategies available for setting them.  An advantage of the SF-OGD and SAOCP algorithms in this respect are that their main tuning parameter, the maximum radius $D$, is easily interpretable as the maximum possible difference between the input predictions and the truth. It is also straightforward to choose this parameter based on a calibration set, although this strategy does not necessarily work well in cases of distribution shift. We also found that an advantage of the AgACI method is its robustness to the choice of its main tuning parameter, the set of candidate learning rates. Indeed, if AgACI does not perform well, one can simply increase the number of candidate learning rates.  </span>
<span id="cb1-979"><a href="#cb1-979" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-980"><a href="#cb1-980" aria-hidden="true" tabindex="-1"></a>A key challenge in tuning the algorithms arises in settings of distribution shift, where methods for choosing hyperparameters based on a calibration set from before the distribution shift will likely not perform well. The second simulation study we conducted probed this setting in a simple scenario. We found that several of the methods yielded prediction intervals that had non-optimal empirical coverage. As we picked hyperparameters based on a calibration set formed before the distribution shift, it is not surprising that the resulting tuning parameters are not optimal. This underscores the difficulty in designing  ACI algorithms that can adapt to distribution shifts, and in finding robust methods for choosing hyperparameters. In practice, it is possible the second simulation study does not accurately reflect real-world scenarios. Indeed, the benchmarks presented in @bhatnagar2023saocp using the datasets from the M4 competition <span class="co">[</span><span class="ot">@makridakis2020m4</span><span class="co">]</span>, and using point predictions generated by diverse prediction algorithms, found that ACI algorithms exhibited good performance in terms of empirical coverage.  Nevertheless, our recommendation for future papers in this line of research is to include simulation studies for simple distributional shift scenarios as a benchmark. </span>
<span id="cb1-981"><a href="#cb1-981" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-982"><a href="#cb1-982" aria-hidden="true" tabindex="-1"></a>Our case study results illustrate the dependence of the ACI algorithms on having access to high-quality point predictions. If the predictions are biased, for example, then the prediction intervals may be able to achieve optimal coverage at the expense of larger interval widths. Using ensemble methods to combine forecasts from several flexible machine learning models is one strategy that can be used to hedge against model misspecification and improve the quality of forecasts <span class="co">[</span><span class="ot">@makridakis2020m4</span><span class="co">]</span>.</span>
<span id="cb1-983"><a href="#cb1-983" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-984"><a href="#cb1-984" aria-hidden="true" tabindex="-1"></a>There remain many possible extensions of ACI algorithms. The algorithms presented in this work primarily consider symmetric intervals evaluated using the pinball loss function (AgACI can yield asymmetric intervals because the aggregation rule is applied separately to the lower and upper bounds from the underlying experts, but those underlying experts only produce symmetric intervals). A simple extension would switch to using the interval loss function <span class="co">[</span><span class="ot">@gneiting2007scoring</span><span class="co">]</span>, which would allow for asymmetric intervals where two parameters are learned for the upper and lower bounds, respectively. It may also be of interest to generate prediction intervals that have coverage guarantees for arbitrary subsets of observations (for example, we may seek prediction intervals for daily observations that have near optimal coverage for every day of the week, or month of the year), similar to guarantees provided by the MultiValid Prediction method described in <span class="co">[</span><span class="ot">@bastani2022practical</span><span class="co">]</span>. Another avenue for theoretical research is to propose algorithms with provable bounds for the coverage and regret that do not depend on the outcome being bounded. </span>
<span id="cb1-985"><a href="#cb1-985" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-986"><a href="#cb1-986" aria-hidden="true" tabindex="-1"></a><span class="fu">## Acknowledgements {.unnumbered}</span></span>
<span id="cb1-987"><a href="#cb1-987" aria-hidden="true" tabindex="-1"></a>This research is partially supported by the Agence Nationale de la Recherche as part of the “Investissements d’avenir” program (reference ANR-19-P3IA-0001; PRAIRIE 3IA Institute). We would like to thank Margaux Zaffran for providing helpful comments on the manuscript.</span>
<span id="cb1-988"><a href="#cb1-988" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-989"><a href="#cb1-989" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-990"><a href="#cb1-990" aria-hidden="true" tabindex="-1"></a><span class="fu"># References {.unnumbered}</span></span>
<span id="cb1-991"><a href="#cb1-991" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-992"><a href="#cb1-992" aria-hidden="true" tabindex="-1"></a>::: {#refs}</span>
<span id="cb1-993"><a href="#cb1-993" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb1-994"><a href="#cb1-994" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-995"><a href="#cb1-995" aria-hidden="true" tabindex="-1"></a><span class="fu"># Appendix</span></span>
<span id="cb1-996"><a href="#cb1-996" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-997"><a href="#cb1-997" aria-hidden="true" tabindex="-1"></a><span class="fu">## Additional simulation study results</span></span>
<span id="cb1-998"><a href="#cb1-998" aria-hidden="true" tabindex="-1"></a><span class="in">```{r simulation_one_plot_appendix}</span></span>
<span id="cb1-999"><a href="#cb1-999" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Coverage errors, mean interval widths, and path lengths for the first simulation study with target coverage $\\alpha \\in \\{ 0.8, 0.9, 0.95 \\}$."</span></span>
<span id="cb1-1000"><a href="#cb1-1000" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 9 </span></span>
<span id="cb1-1001"><a href="#cb1-1001" aria-hidden="true" tabindex="-1"></a><span class="fu">simulation_one_plot</span>(simulation_study1<span class="sc">$</span>results)</span>
<span id="cb1-1002"><a href="#cb1-1002" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-1003"><a href="#cb1-1003" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1004"><a href="#cb1-1004" aria-hidden="true" tabindex="-1"></a><span class="in">```{r simulation_one_plot_joint_appendix}</span></span>
<span id="cb1-1005"><a href="#cb1-1005" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-simulation-one-joint</span></span>
<span id="cb1-1006"><a href="#cb1-1006" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Mean Interval Width vs Coverage Error for the first simulation study. The error bars represent the 10% to 90% quantiles of the metrics over the simulation datasets."</span></span>
<span id="cb1-1007"><a href="#cb1-1007" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 4 </span></span>
<span id="cb1-1008"><a href="#cb1-1008" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1009"><a href="#cb1-1009" aria-hidden="true" tabindex="-1"></a><span class="fu">simulation_one_joint_plot</span>(simulation_study1<span class="sc">$</span>results)</span>
<span id="cb1-1010"><a href="#cb1-1010" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb1-1011"><a href="#cb1-1011" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1012"><a href="#cb1-1012" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1013"><a href="#cb1-1013" aria-hidden="true" tabindex="-1"></a><span class="in">```{r simulation_two_plot}</span></span>
<span id="cb1-1014"><a href="#cb1-1014" aria-hidden="true" tabindex="-1"></a><span class="co">#| label: fig-simulation-two-results</span></span>
<span id="cb1-1015"><a href="#cb1-1015" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-height: 9</span></span>
<span id="cb1-1016"><a href="#cb1-1016" aria-hidden="true" tabindex="-1"></a><span class="co">#| fig-cap: "Coverage error, mean interval width, and path length for $\\alpha = 0.8, 0.9, 0.95$ and simulations with and without distributional shift."</span></span>
<span id="cb1-1017"><a href="#cb1-1017" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-1018"><a href="#cb1-1018" aria-hidden="true" tabindex="-1"></a><span class="fu">simulation_two_plot</span>(simulation_study2<span class="sc">$</span>results)</span>
<span id="cb1-1019"><a href="#cb1-1019" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<script>
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    let pseudocodeOptions = {
      indentSize: el.dataset.indentSize || "1.2em",
      commentDelimiter: el.dataset.commentDelimiter || "//",
      lineNumber: el.dataset.lineNumber === "true" ? true : false,
      lineNumberPunc: el.dataset.lineNumberPunc || ":",
      noEnd: el.dataset.noEnd === "true" ? true : false,
      titlePrefix: el.dataset.algTitle || "Algorithm"
    };
    pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
  });
})(document);
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
    titlePrefix = el.dataset.algTitle;
    titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
    titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
  });
})(document);
</script>
<script>
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    let pseudocodeOptions = {
      indentSize: el.dataset.indentSize || "1.2em",
      commentDelimiter: el.dataset.commentDelimiter || "//",
      lineNumber: el.dataset.lineNumber === "true" ? true : false,
      lineNumberPunc: el.dataset.lineNumberPunc || ":",
      noEnd: el.dataset.noEnd === "true" ? true : false,
      titlePrefix: el.dataset.algTitle || "Algorithm"
    };
    pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
  });
})(document);
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
    titlePrefix = el.dataset.algTitle;
    titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
    titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
  });
})(document);
</script>
<script>
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    let pseudocodeOptions = {
      indentSize: el.dataset.indentSize || "1.2em",
      commentDelimiter: el.dataset.commentDelimiter || "//",
      lineNumber: el.dataset.lineNumber === "true" ? true : false,
      lineNumberPunc: el.dataset.lineNumberPunc || ":",
      noEnd: el.dataset.noEnd === "true" ? true : false,
      titlePrefix: el.dataset.algTitle || "Algorithm"
    };
    pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
  });
})(document);
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
    titlePrefix = el.dataset.algTitle;
    titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
    titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
  });
})(document);
</script>
<script>
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    let pseudocodeOptions = {
      indentSize: el.dataset.indentSize || "1.2em",
      commentDelimiter: el.dataset.commentDelimiter || "//",
      lineNumber: el.dataset.lineNumber === "true" ? true : false,
      lineNumberPunc: el.dataset.lineNumberPunc || ":",
      noEnd: el.dataset.noEnd === "true" ? true : false,
      titlePrefix: el.dataset.algTitle || "Algorithm"
    };
    pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
  });
})(document);
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
    titlePrefix = el.dataset.algTitle;
    titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
    titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
  });
})(document);
</script>
<script>
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    let pseudocodeOptions = {
      indentSize: el.dataset.indentSize || "1.2em",
      commentDelimiter: el.dataset.commentDelimiter || "//",
      lineNumber: el.dataset.lineNumber === "true" ? true : false,
      lineNumberPunc: el.dataset.lineNumberPunc || ":",
      noEnd: el.dataset.noEnd === "true" ? true : false,
      titlePrefix: el.dataset.algTitle || "Algorithm"
    };
    pseudocode.renderElement(el.querySelector(".pseudocode"), pseudocodeOptions);
  });
})(document);
(function(d) {
  d.querySelectorAll(".pseudocode-container").forEach(function(el) {
    titleSpan = el.querySelector(".ps-root > .ps-algorithm > .ps-line > .ps-keyword")
    titlePrefix = el.dataset.algTitle;
    titleIndex = el.dataset.chapterLevel ? el.dataset.chapterLevel + "." + el.dataset.pseudocodeIndex : el.dataset.pseudocodeIndex;
    titleSpan.innerHTML = titlePrefix + " " + titleIndex + " ";
  });
})(document);
</script>



</body></html>